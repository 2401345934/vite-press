import{_ as o,o as r,c as n,J as a,w as p,m as e,a as c,aa as d,E as t}from"./chunks/framework.DJCjJe2w.js";const x=JSON.parse('{"title":"UDP","description":"","frontmatter":{"createTime":"2022/10/26","tag":"计算机"},"headers":[],"relativePath":"basic-quality/udp/index.md","filePath":"basic-quality/udp/index.md","lastUpdated":1667281923000}'),s={name:"basic-quality/udp/index.md"},P=e("h1",{id:"udp",tabindex:"-1"},[c("UDP "),e("a",{class:"header-anchor",href:"#udp","aria-label":'Permalink to "UDP"'},"​")],-1),h=d('<p>首先 UDP 协议是面向无连接的，也就是说不需要在正式传递数据之前先连接起双方。然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便。</p><h2 id="面向无连接" tabindex="-1">面向无连接 <a class="header-anchor" href="#面向无连接" aria-label="Permalink to &quot;面向无连接&quot;">​</a></h2><p>首先 UDP 是不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。</p><p>并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p><p>具体来说就是：</p><ul><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ul><h2 id="不可靠性" tabindex="-1">不可靠性 <a class="header-anchor" href="#不可靠性" aria-label="Permalink to &quot;不可靠性&quot;">​</a></h2><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p><p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p><p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p><h2 id="高效" tabindex="-1">高效 <a class="header-anchor" href="#高效" aria-label="Permalink to &quot;高效&quot;">​</a></h2><p>虽然 UDP 协议不是那么的可靠，但是正是因为它不是那么的可靠，所以也就没有 TCP 那么复杂了，需要保证数据不丢失且有序到达。</p><p>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70eba4f3d5f34211b26cd5a6acbbba22~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p><p>UDP 头部包含了以下几个数据</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li></ul><h2 id="传输方式" tabindex="-1">传输方式 <a class="header-anchor" href="#传输方式" aria-label="Permalink to &quot;传输方式&quot;">​</a></h2><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p><h2 id="适合使用的场景" tabindex="-1">适合使用的场景 <a class="header-anchor" href="#适合使用的场景" aria-label="Permalink to &quot;适合使用的场景&quot;">​</a></h2><p>UDP 虽然对比 TCP 有很多缺点，但是正是因为这些缺点造就了它高效的特性，在很多实时性要求高的地方都可以看到 UDP 的身影。</p><h2 id="udp-vs-tcp" tabindex="-1">UDP vs TCP <a class="header-anchor" href="#udp-vs-tcp" aria-label="Permalink to &quot;UDP vs TCP&quot;">​</a></h2><ul><li>UDP 相比 TCP 简单的多，不需要建立连接，不需要验证数据报文，不需要流量控制，只会把想发的数据报文一股脑的丢给对端</li><li>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</li></ul>',22);function u(_,D,U,m,b,f){const i=t("ArticleMetadata"),l=t("ClientOnly");return r(),n("div",null,[P,a(l,null,{default:p(()=>[a(i)]),_:1}),h])}const C=o(s,[["render",u]]);export{x as __pageData,C as default};
