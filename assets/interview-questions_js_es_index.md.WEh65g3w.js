import{_ as l,o as i,c as r,J as s,w as t,m as n,a as c,aa as o,E as a}from"./chunks/framework.DJCjJe2w.js";const q=JSON.parse('{"title":"从ES6到ES10","description":"","frontmatter":{"createTime":"2022/11/04","tag":"js,面试题"},"headers":[],"relativePath":"interview-questions/js/es/index.md","filePath":"interview-questions/js/es/index.md","lastUpdated":1667791517000}'),b={name:"interview-questions/js/es/index.md"},d=n("h1",{id:"从es6到es10",tabindex:"-1"},[c("从ES6到ES10 "),n("a",{class:"header-anchor",href:"#从es6到es10","aria-label":'Permalink to "从ES6到ES10"'},"​")],-1),u=o(`<h3 id="历史版本" tabindex="-1">历史版本 <a class="header-anchor" href="#历史版本" aria-label="Permalink to &quot;历史版本&quot;">​</a></h3><p>至发稿日为止有九个ECMA-262版本发表。其历史版本如下：</p><ol><li>1997年6月：第一版</li><li>1998年6月：修改格式，使其与ISO/IEC16262国际标准一样</li><li>1999年12月：强大的正则表达式，更好的词法作用域链处理，新的控制指令，异常处理，错误定义更加明确，数据输出的格式化及其它改变</li><li>2009年12月：添加严格模式(<code>&quot;use strict&quot;</code>)。修改了前面版本模糊不清的概念。增加了getters，setters，JSON以及在对象属性上更完整的反射。</li><li>2011年6月：ECMAScript标5.1版形式上完全一致于国际标准ISO/IEC 16262:2011。</li><li>2015年6月：ECMAScript 2015（ES2015），第 6 版，最早被称作是 ECMAScript 6（ES6），添加了类和模块的语法，其他特性包括迭代器，Python风格的生成器和生成器表达式，箭头函数，二进制数据，静态类型数组，集合（maps，sets 和 weak maps），promise，reflection 和 proxies。作为最早的 ECMAScript Harmony 版本，也被叫做ES6 Harmony。</li><li>2016年6月：ECMAScript 2016（ES2016），第 7 版，多个新的概念和语言特性。</li><li>2017年6月：ECMAScript 2017（ES2017），第 8 版，多个新的概念和语言特性。</li><li>2018年6月：ECMAScript 2018 （ES2018），第 9 版，包含了异步循环，生成器，新的正则表达式特性和 rest/spread 语法。</li><li>2019年6月：ECMAScript 2019 （ES2019），第 10 版。</li></ol><h3 id="发展标准" tabindex="-1">发展标准 <a class="header-anchor" href="#发展标准" aria-label="Permalink to &quot;发展标准&quot;">​</a></h3><p>TC39（Technical Committee 39）是一个推动JavaScript发展的委员会，它的成语来自各个主流浏览器的代表成语。会议实行多数决，每一项决策只有大部分人同意且没有强烈反对才能去实现。</p><p>TC39成员制定着ECMAScript的未来。</p><p>每一项新特性最终要进入到ECMAScript规范里，需要经历5个阶段，这5个阶段如下：</p><ul><li><p><strong>Stage 0</strong>: Strawperson</p><p>只要是TC39成员或者贡献者，都可以提交想法</p></li><li><p><strong>Stage 1</strong>: Proposal</p><p>这个阶段确定一个正式的提案</p></li><li><p><strong>Stage 2</strong>: draft</p><p>规范的第一个版本，进入此阶段的提案大概率会成为标准</p></li><li><p><strong>Stage 3</strong>: Candidate</p><p>进一步完善提案细则</p></li><li><p><strong>Stage 4</strong>: Finished</p><p>表示已准备好将其添加到正式的ECMAScript标准中</p></li></ul><p><strong>由于ES6以前的属性诞生年底久远，我们使用也比较普遍，遂不进行说明，ES6之后的语言风格跟ES5以前的差异比较大，所以单独拎出来做个记录。</strong></p><h2 id="es6-es2015" tabindex="-1">ES6(ES2015) <a class="header-anchor" href="#es6-es2015" aria-label="Permalink to &quot;ES6(ES2015)&quot;">​</a></h2><blockquote><p>ES6是一次重大的革新，比起过去的版本，改动比较大，本文仅对常用的API以及语法糖进行讲解。</p></blockquote><h3 id="let-和-const" tabindex="-1">Let 和 Const <a class="header-anchor" href="#let-和-const" aria-label="Permalink to &quot;Let 和 Const&quot;">​</a></h3><p>在ES6以前，<code>JS</code>只有<code>var</code>一种声明方式，但是在ES6之后，就多了<code>let</code>跟<code>const</code>这两种方式。用<code>var</code>定义的变量没有块级作用域的概念，而<code>let</code>跟<code>const</code>则会有，因为这三个关键字创建是不一样的。</p><p>区别如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>{</span></span>
<span class="line"><span>    var a = 10</span></span>
<span class="line"><span>    let b = 20</span></span>
<span class="line"><span>    const c = 30</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>a // 10</span></span>
<span class="line"><span>b // Uncaught ReferenceError: b is not defined</span></span>
<span class="line"><span>c // c is not defined</span></span>
<span class="line"><span>let d = 40</span></span>
<span class="line"><span>const e = 50</span></span>
<span class="line"><span>d = 60</span></span>
<span class="line"><span>d // 60</span></span>
<span class="line"><span>e = 70 // VM231:1 Uncaught TypeError: Assignment to constant variable.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><table><thead><tr><th></th><th>var</th><th>let</th><th>const</th></tr></thead><tbody><tr><td>变量提升</td><td>√</td><td>×</td><td>×</td></tr><tr><td>全局变量</td><td>√</td><td>×</td><td>×</td></tr><tr><td>重复声明</td><td>√</td><td>×</td><td>×</td></tr><tr><td>重新赋值</td><td>√</td><td>√</td><td>×</td></tr><tr><td>暂时死区</td><td>×</td><td>√</td><td>√</td></tr><tr><td>块作用域</td><td>×</td><td>√</td><td>√</td></tr><tr><td>只声明不初始化</td><td>√</td><td>√</td><td>×</td></tr></tbody></table><h3 id="类-class" tabindex="-1">类（Class） <a class="header-anchor" href="#类-class" aria-label="Permalink to &quot;类（Class）&quot;">​</a></h3><p>在ES6之前，如果我们要生成一个实例对象，传统的方法就是写一个构造函数，例子如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function Person(name, age) {</span></span>
<span class="line"><span>    this.name = name</span></span>
<span class="line"><span>    this.age = age</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>Person.prototype.information = function () {</span></span>
<span class="line"><span>    return &#39;My name is &#39; + this.name + &#39;, I am &#39; + this.age</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>但是在ES6之后，我们只需要写成以下形式：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Person {</span></span>
<span class="line"><span>    constructor(name, age) {</span></span>
<span class="line"><span>        this.name = name</span></span>
<span class="line"><span>        this.age = age</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    information() {</span></span>
<span class="line"><span>        return &#39;My name is &#39; + this.name + &#39;, I am &#39; + this.age</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="箭头函数-arrow-function" tabindex="-1">箭头函数（Arrow function） <a class="header-anchor" href="#箭头函数-arrow-function" aria-label="Permalink to &quot;箭头函数（Arrow function）&quot;">​</a></h3><p>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或 <code>new.target</code>。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。</p><p>在ES6以前，我们写函数一般是：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var list = [1, 2, 3, 4, 5, 6, 7]</span></span>
<span class="line"><span>var newList = list.map(function (item) {</span></span>
<span class="line"><span>    return item * item</span></span>
<span class="line"><span>})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>但是在ES6里，我们可以：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const list = [1, 2, 3, 4, 5, 6, 7]</span></span>
<span class="line"><span>const newList = list.map(item =&gt; item * item)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>看，是不是简洁了不少</p><h3 id="函数参数默认值-function-parameter-defaults" tabindex="-1">函数参数默认值（Function parameter defaults） <a class="header-anchor" href="#函数参数默认值-function-parameter-defaults" aria-label="Permalink to &quot;函数参数默认值（Function parameter defaults）&quot;">​</a></h3><p>在ES6之前，如果我们写函数需要定义初始值的时候，需要这么写：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function config (data) {</span></span>
<span class="line"><span>    var data = data || &#39;data is empty&#39;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这样看起来也没有问题，但是如果参数的布尔值为<strong>falsy</strong>时就会出问题，例如我们这样调用config：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>config(0)</span></span>
<span class="line"><span>config(&#39;&#39;)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>那么结果就永远是后面的值</p><p>如果我们用函数参数默认值就没有这个问题，写法如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const config = (data = &#39;data is empty&#39;) =&gt; {}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="模板字符串-template-string" tabindex="-1">模板字符串（Template string） <a class="header-anchor" href="#模板字符串-template-string" aria-label="Permalink to &quot;模板字符串（Template string）&quot;">​</a></h3><p>在ES6之前，如果我们要拼接字符串，则需要像这样：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var name = &#39;kris&#39;</span></span>
<span class="line"><span>var age = 24</span></span>
<span class="line"><span>var info = &#39;My name is &#39; + this.name + &#39;, I am &#39; + this.age</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>但是在ES6之后，我们只需要写成以下形式：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const name = &#39;kris&#39;</span></span>
<span class="line"><span>const age = 24</span></span>
<span class="line"><span>const info = \`My name is \${name}, I am \${age}\`</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="解构赋值-destructuring-assignment" tabindex="-1">解构赋值（Destructuring assignment） <a class="header-anchor" href="#解构赋值-destructuring-assignment" aria-label="Permalink to &quot;解构赋值（Destructuring assignment）&quot;">​</a></h3><p>我们通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。</p><p>比如我们需要交换两个变量的值，在ES6之前我们可能需要：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var a = 10</span></span>
<span class="line"><span>var b = 20</span></span>
<span class="line"><span>var temp = a</span></span>
<span class="line"><span>a = b</span></span>
<span class="line"><span>b = temp</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>但是在ES6里，我们有：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let a = 10</span></span>
<span class="line"><span>let b = 20</span></span>
<span class="line"><span>[a, b] = [b, a]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>是不是方便很多</p><h3 id="模块化-module" tabindex="-1">模块化（Module） <a class="header-anchor" href="#模块化-module" aria-label="Permalink to &quot;模块化（Module）&quot;">​</a></h3><p>在ES6之前，JS并没有模块化的概念，有的也只是社区定制的类似CommonJS和AMD之类的规则。例如基于CommonJS的NodeJS：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// circle.js</span></span>
<span class="line"><span>// 输出</span></span>
<span class="line"><span>const { PI } = Math</span></span>
<span class="line"><span>exports.area = (r) =&gt; PI * r ** 2</span></span>
<span class="line"><span>exports.circumference = (r) =&gt; 2 * PI * r</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// index.js</span></span>
<span class="line"><span>// 输入</span></span>
<span class="line"><span>const circle = require(&#39;./circle.js&#39;)</span></span>
<span class="line"><span>console.log(\`半径为 4 的圆的面积是 \${circle.area(4)}\`)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在ES6之后我们则可以写成以下形式：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// circle.js</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> area</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">r</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> PI</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">**</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> circumference</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">r</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> PI</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// index.js</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输入</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    area</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./circle.js&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.log(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`半径为 4 的圆的面积是: \${</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">area</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="扩展操作符-spread-operator" tabindex="-1">扩展操作符（Spread operator） <a class="header-anchor" href="#扩展操作符-spread-operator" aria-label="Permalink to &quot;扩展操作符（Spread operator）&quot;">​</a></h3><p>扩展操作符可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。</p><p>比如在ES5的时候，我们要对一个数组的元素进行相加，在不使用<code>reduce</code>或者<code>reduceRight</code>的场合，我们需要：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function sum(x, y, z) {</span></span>
<span class="line"><span>    return x + y + z;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var list = [5, 6, 7]</span></span>
<span class="line"><span>var total = sum.apply(null, list)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>但是如果我们使用扩展操作符，只需要如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const sum = (x, y, z) =&gt; x + y + z</span></span>
<span class="line"><span>const list = [5, 6, 7]</span></span>
<span class="line"><span>const total = sum(...list)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>非常的简单，但是要注意的是扩展操作符只能用于可迭代对象</p><p>如果是下面的情况，是会报错的：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var obj = {&#39;key1&#39;: &#39;value1&#39;}</span></span>
<span class="line"><span>var array = [...obj] // TypeError: obj is not iterable</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="对象属性简写-object-attribute-shorthand" tabindex="-1">对象属性简写（Object attribute shorthand） <a class="header-anchor" href="#对象属性简写-object-attribute-shorthand" aria-label="Permalink to &quot;对象属性简写（Object attribute shorthand）&quot;">​</a></h3><p>在ES6之前，如果我们要将某个变量赋值为同样名称的对象元素，则需要：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var cat = &#39;Miaow&#39;</span></span>
<span class="line"><span>var dog = &#39;Woof&#39;</span></span>
<span class="line"><span>var bird = &#39;Peet peet&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var someObject = {</span></span>
<span class="line"><span>  cat: cat,</span></span>
<span class="line"><span>  dog: dog,</span></span>
<span class="line"><span>  bird: bird</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>但是在ES6里我们就方便很多：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let cat = &#39;Miaow&#39;</span></span>
<span class="line"><span>let dog = &#39;Woof&#39;</span></span>
<span class="line"><span>let bird = &#39;Peet peet&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>let someObject = {</span></span>
<span class="line"><span>  cat,</span></span>
<span class="line"><span>  dog,</span></span>
<span class="line"><span>  bird</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(someObject)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//{</span></span>
<span class="line"><span>//  cat: &quot;Miaow&quot;,</span></span>
<span class="line"><span>//  dog: &quot;Woof&quot;,</span></span>
<span class="line"><span>//  bird: &quot;Peet peet&quot;</span></span>
<span class="line"><span>//}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>非常方便</p><h3 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-label="Permalink to &quot;Promise&quot;">​</a></h3><p>Promise 是ES6提供的一种异步解决方案，比回调函数更加清晰明了。</p><p><code>Promise</code> 翻译过来就是承诺的意思，这个承诺会在未来有一个确切的答复，并且该承诺有三种状态，分别是：</p><ol><li>等待中（pending）</li><li>完成了 （resolved）</li><li>拒绝了（rejected）</li></ol><p>这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 resolved 后，就不能再次改变</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span>  resolve(&#39;success&#39;)</span></span>
<span class="line"><span>  // 无效</span></span>
<span class="line"><span>  reject(&#39;reject&#39;)</span></span>
<span class="line"><span>})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>当我们在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span>  console.log(&#39;new Promise&#39;)</span></span>
<span class="line"><span>  resolve(&#39;success&#39;)</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span>console.log(&#39;finifsh&#39;)</span></span>
<span class="line"><span>// new Promise -&gt; finifsh</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><code>Promise</code> 实现了链式调用，也就是说每次调用 <code>then</code> 之后返回的都是一个 <code>Promise</code>，并且是一个全新的 <code>Promise</code>，原因也是因为状态不可变。如果你在 <code>then</code> 中 使用了 <code>return</code>，那么 <code>return</code> 的值会被 <code>Promise.resolve()</code> 包装</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Promise.resolve(1)</span></span>
<span class="line"><span>  .then(res =&gt; {</span></span>
<span class="line"><span>    console.log(res) // =&gt; 1</span></span>
<span class="line"><span>    return 2 // 包装成 Promise.resolve(2)</span></span>
<span class="line"><span>  })</span></span>
<span class="line"><span>  .then(res =&gt; {</span></span>
<span class="line"><span>    console.log(res) // =&gt; 2</span></span>
<span class="line"><span>  })</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>当然了，<code>Promise</code> 也很好地解决了回调地狱的问题，例如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>ajax(url, () =&gt; {</span></span>
<span class="line"><span>    // 处理逻辑</span></span>
<span class="line"><span>    ajax(url1, () =&gt; {</span></span>
<span class="line"><span>        // 处理逻辑</span></span>
<span class="line"><span>        ajax(url2, () =&gt; {</span></span>
<span class="line"><span>            // 处理逻辑</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>可以改写成：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>ajax(url)</span></span>
<span class="line"><span>  .then(res =&gt; {</span></span>
<span class="line"><span>      console.log(res)</span></span>
<span class="line"><span>      return ajax(url1)</span></span>
<span class="line"><span>  }).then(res =&gt; {</span></span>
<span class="line"><span>      console.log(res)</span></span>
<span class="line"><span>      return ajax(url2)</span></span>
<span class="line"><span>  }).then(res =&gt; console.log(res))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="for-of" tabindex="-1">for...of <a class="header-anchor" href="#for-of" aria-label="Permalink to &quot;for...of&quot;">​</a></h3><p><code>for...of</code>语句在可迭代对象（包括 <code>Array，Map，Set，String，TypedArray，arguments</code> 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。</p><p>例子如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>for (const element of array1) {</span></span>
<span class="line"><span>      console.log(element)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// &quot;a&quot;</span></span>
<span class="line"><span>// &quot;b&quot;</span></span>
<span class="line"><span>// &quot;c&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="symbol" tabindex="-1">Symbol <a class="header-anchor" href="#symbol" aria-label="Permalink to &quot;Symbol&quot;">​</a></h3><p><strong>symbol</strong> 是一种基本数据类型，<code>Symbol()</code>函数会返回<strong>symbol</strong>类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：&quot;<code>new Symbol()</code>&quot;。</p><p>每个从<code>Symbol()</code>返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。</p><p>例子如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const symbol1 = Symbol();</span></span>
<span class="line"><span>const symbol2 = Symbol(42);</span></span>
<span class="line"><span>const symbol3 = Symbol(&#39;foo&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(typeof symbol1); // &quot;symbol&quot;</span></span>
<span class="line"><span>console.log(symbol3.toString()); // &quot;Symbol(foo)&quot;</span></span>
<span class="line"><span>console.log(Symbol(&#39;foo&#39;) === Symbol(&#39;foo&#39;)); // false</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="迭代器-iterator-生成器-generator" tabindex="-1">迭代器（Iterator）/ 生成器（Generator） <a class="header-anchor" href="#迭代器-iterator-生成器-generator" aria-label="Permalink to &quot;迭代器（Iterator）/ 生成器（Generator）&quot;">​</a></h3><p>迭代器（Iterator）是一种迭代的机制，为各种不同的数据结构提供统一的访问机制。任何数据结构只要内部有 Iterator 接口，就可以完成依次迭代操作。</p><p>一旦创建，迭代器对象可以通过重复调用next()显式地迭代，从而获取该对象每一级的值，直到迭代完，返回<code>{ value: undefined, done: true }</code></p><p>虽然自定义的迭代器是一个有用的工具，但由于需要显式地维护其内部状态，因此需要谨慎地创建。生成器函数提供了一个强大的选择：它允许你定义一个包含自有迭代算法的函数， 同时它可以自动维护自己的状态。 生成器函数使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Ffunction*" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="noreferrer"><code>function*</code></a>语法编写。 最初调用时，生成器函数不执行任何代码，而是返回一种称为Generator的迭代器。 通过调用生成器的下一个方法消耗值时，Generator函数将执行，直到遇到yield关键字。</p><p>可以根据需要多次调用该函数，并且每次都返回一个新的Generator，但每个Generator只能迭代一次。</p><p>所以我们可以有以下例子：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function* makeRangeIterator(start = 0, end = Infinity, step = 1) {</span></span>
<span class="line"><span>    for (let i = start; i &lt; end; i += step) {</span></span>
<span class="line"><span>        yield i;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var a = makeRangeIterator(1,10,2)</span></span>
<span class="line"><span>a.next() // {value: 1, done: false}</span></span>
<span class="line"><span>a.next() // {value: 3, done: false}</span></span>
<span class="line"><span>a.next() // {value: 5, done: false}</span></span>
<span class="line"><span>a.next() // {value: 7, done: false}</span></span>
<span class="line"><span>a.next() // {value: 9, done: false}</span></span>
<span class="line"><span>a.next() // {value: undefined, done: true}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="set-weakset" tabindex="-1">Set/WeakSet <a class="header-anchor" href="#set-weakset" aria-label="Permalink to &quot;Set/WeakSet&quot;">​</a></h3><p><code>Set</code> 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p><p>所以我们可以通过<code>Set</code>实现数组去重</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const numbers = [2,3,4,4,2,3,3,4,4,5,5,6,6,7,5,32,3,4,5]</span></span>
<span class="line"><span>console.log([...new Set(numbers)]) </span></span>
<span class="line"><span>// [2, 3, 4, 5, 6, 7, 32]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>WeakSet</code> 结构与 <code>Set</code> 类似，但区别有以下两点：</p><ul><li><code>WeakSet</code> 对象中只能存放对象引用, 不能存放值, 而 <code>Set</code> 对象都可以。</li><li><code>WeakSet</code> 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, <code>WeakSet</code> 对象是无法被枚举的, 没有办法拿到它包含的所有元素。</li></ul><p>所以代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var ws = new WeakSet()</span></span>
<span class="line"><span>var obj = {}</span></span>
<span class="line"><span>var foo = {}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ws.add(window)</span></span>
<span class="line"><span>ws.add(obj)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ws.has(window) // true</span></span>
<span class="line"><span>ws.has(foo)    // false, 对象 foo 并没有被添加进 ws 中 </span></span>
<span class="line"><span></span></span>
<span class="line"><span>ws.delete(window) // 从集合中删除 window 对象</span></span>
<span class="line"><span>ws.has(window)    // false, window 对象已经被删除了</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ws.clear() // 清空整个 WeakSet 对象</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="map-weakmap" tabindex="-1">Map/WeakMap <a class="header-anchor" href="#map-weakmap" aria-label="Permalink to &quot;Map/WeakMap&quot;">​</a></h3><p><code>Map</code> 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p><p>例子如下，我们甚至可以使用<code>NaN</code>来作为键值：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var myMap = new Map();</span></span>
<span class="line"><span>myMap.set(NaN, &quot;not a number&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>myMap.get(NaN); // &quot;not a number&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var otherNaN = Number(&quot;foo&quot;);</span></span>
<span class="line"><span>myMap.get(otherNaN); // &quot;not a number&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><code>WeakMap</code> 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</p><p>跟<code>Map</code>的区别与<code>Set</code>跟<code>WeakSet</code>的区别相似，具体代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var wm1 = new WeakMap(),</span></span>
<span class="line"><span>    wm2 = new WeakMap(),</span></span>
<span class="line"><span>    wm3 = new WeakMap();</span></span>
<span class="line"><span>var o1 = {},</span></span>
<span class="line"><span>    o2 = function(){},</span></span>
<span class="line"><span>    o3 = window;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>wm1.set(o1, 37);</span></span>
<span class="line"><span>wm1.set(o2, &quot;azerty&quot;);</span></span>
<span class="line"><span>wm2.set(o1, o2); // value可以是任意值,包括一个对象</span></span>
<span class="line"><span>wm2.set(o3, undefined);</span></span>
<span class="line"><span>wm2.set(wm1, wm2); // 键和值可以是任意对象,甚至另外一个WeakMap对象</span></span>
<span class="line"><span>wm1.get(o2); // &quot;azerty&quot;</span></span>
<span class="line"><span>wm2.get(o2); // undefined,wm2中没有o2这个键</span></span>
<span class="line"><span>wm2.get(o3); // undefined,值就是undefined</span></span>
<span class="line"><span></span></span>
<span class="line"><span>wm1.has(o2); // true</span></span>
<span class="line"><span>wm2.has(o2); // false</span></span>
<span class="line"><span>wm2.has(o3); // true (即使值是undefined)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>wm3.set(o1, 37);</span></span>
<span class="line"><span>wm3.get(o1); // 37</span></span>
<span class="line"><span>wm3.clear();</span></span>
<span class="line"><span>wm3.get(o1); // undefined,wm3已被清空</span></span>
<span class="line"><span>wm1.has(o1);   // true</span></span>
<span class="line"><span>wm1.delete(o1);</span></span>
<span class="line"><span>wm1.has(o1);   // false</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h3 id="proxy-reflect" tabindex="-1">Proxy/Reflect <a class="header-anchor" href="#proxy-reflect" aria-label="Permalink to &quot;Proxy/Reflect&quot;">​</a></h3><p><code>Proxy</code> 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。</p><p><code>Reflect</code> 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 <code>Proxy</code> 的方法相同。<code>Reflect</code>不是一个函数对象，因此它是不可构造的。</p><p><code>Proxy</code>跟<code>Reflect</code>是非常完美的配合，例子如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const observe = (data, callback) =&gt; {</span></span>
<span class="line"><span>      return new Proxy(data, {</span></span>
<span class="line"><span>            get(target, key) {</span></span>
<span class="line"><span>                return Reflect.get(target, key)</span></span>
<span class="line"><span>            },</span></span>
<span class="line"><span>            set(target, key, value, proxy) {</span></span>
<span class="line"><span>                  callback(key, value);</span></span>
<span class="line"><span>                  target[key] = value;</span></span>
<span class="line"><span>                    return Reflect.set(target, key, value, proxy)</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>      })</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const FooBar = { open: false };</span></span>
<span class="line"><span>const FooBarObserver = observe(FooBar, (property, value) =&gt; {</span></span>
<span class="line"><span>  property === &#39;open&#39; &amp;&amp; value </span></span>
<span class="line"><span>          ? console.log(&#39;FooBar is open!!!&#39;) </span></span>
<span class="line"><span>          : console.log(&#39;keep waiting&#39;);</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span>console.log(FooBarObserver.open) // false</span></span>
<span class="line"><span>FooBarObserver.open = true // FooBar is open!!!</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>当然也不是什么都可以被代理的，如果对象带有<code>configurable: false</code> 跟<code>writable: false</code> 属性，则代理失效。</p><h3 id="regex对象的扩展" tabindex="-1">Regex对象的扩展 <a class="header-anchor" href="#regex对象的扩展" aria-label="Permalink to &quot;Regex对象的扩展&quot;">​</a></h3><h4 id="正则新增符号" tabindex="-1">正则新增符号 <a class="header-anchor" href="#正则新增符号" aria-label="Permalink to &quot;正则新增符号&quot;">​</a></h4><ul><li><p><code>i</code> 修饰符</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// i 修饰符</span></span>
<span class="line"><span>/[a-z]/i.test(&#39;\\u212A&#39;) // false</span></span>
<span class="line"><span>/[a-z]/iu.test(&#39;\\u212A&#39;) // true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p><code>y</code>修饰符</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// y修饰符</span></span>
<span class="line"><span>var s = &#39;aaa_aa_a&#39;;</span></span>
<span class="line"><span>var r1 = /a+/g;</span></span>
<span class="line"><span>var r2 = /a+/y;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>r1.exec(s) // [&quot;aaa&quot;]</span></span>
<span class="line"><span>r2.exec(s) // [&quot;aaa&quot;]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>r1.exec(s) // [&quot;aa&quot;]</span></span>
<span class="line"><span>r2.exec(s) // null</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li><li><p>String.prototype.flags</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 查看RegExp构造函数的修饰符</span></span>
<span class="line"><span>var regex = new RegExp(&#39;xyz&#39;, &#39;i&#39;)</span></span>
<span class="line"><span>regex.flags // &#39;i&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p>unicode模式</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var s = &#39;𠮷&#39;</span></span>
<span class="line"><span>/^.$/.test(s) // false</span></span>
<span class="line"><span>/^.$/u.test(s) // true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p>u转义</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// u转义</span></span>
<span class="line"><span>/\\,/ // /\\,/</span></span>
<span class="line"><span>/\\,/u // 报错 没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p>引用</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\\k&lt;word&gt;$/;</span></span>
<span class="line"><span>RE_TWICE.test(&#39;abc!abc&#39;) // true</span></span>
<span class="line"><span>RE_TWICE.test(&#39;abc!ab&#39;) // false</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\\1$/;</span></span>
<span class="line"><span>RE_TWICE.test(&#39;abc!abc&#39;) // true</span></span>
<span class="line"><span>RE_TWICE.test(&#39;abc!ab&#39;) // false</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li></ul><h4 id="字符串方法的实现改为调用regexp方法" tabindex="-1">字符串方法的实现改为调用<code>RegExp</code>方法 <a class="header-anchor" href="#字符串方法的实现改为调用regexp方法" aria-label="Permalink to &quot;字符串方法的实现改为调用\`RegExp\`方法&quot;">​</a></h4><ul><li><code>String.prototype.match</code> 调用 <code>RegExp.prototype[Symbol.match]</code></li><li><code>String.prototype.replace</code> 调用 <code>RegExp.prototype[Symbol.replace]</code></li><li><code>String.prototype.search</code> 调用 <code>RegExp.prototype[Symbol.search]</code></li><li><code>String.prototype.split</code> 调用 <code>RegExp.prototype[Symbol.split]</code></li></ul><h4 id="正则新增属性" tabindex="-1">正则新增属性 <a class="header-anchor" href="#正则新增属性" aria-label="Permalink to &quot;正则新增属性&quot;">​</a></h4><ul><li><p><code>RegExp.prototype.sticky</code> 表示是否有<code>y</code>修饰符</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>/hello\\d/y.sticky // true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li><p><code>RegExp.prototype.flags</code>获取修饰符</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>/abc/ig.flags // &#39;gi&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li></ul><h3 id="math对象的扩展" tabindex="-1">Math对象的扩展 <a class="header-anchor" href="#math对象的扩展" aria-label="Permalink to &quot;Math对象的扩展&quot;">​</a></h3><ul><li><p><code>二进制表示法</code> : <code>0b或0B开头</code>表示二进制(<code>0bXX</code>或<code>0BXX</code>)</p></li><li><p><code>二进制表示法</code> : <code>0b或0B开头</code>表示二进制(<code>0bXX</code>或<code>0BXX</code>)</p></li><li><p><code>八进制表示法</code> : <code>0o或0O开头</code>表示二进制(<code>0oXX</code>或<code>0OXX</code>)</p></li><li><p><code>Number.EPSILON</code> : 数值最小精度</p></li><li><p><code>Number.MIN_SAFE_INTEGER</code> : 最小安全数值(<code>-2^53</code>)</p></li><li><p><code>Number.MAX_SAFE_INTEGER</code> : 最大安全数值(<code>2^53</code>)</p></li><li><p><code>Number.parseInt()</code> : 返回转换值的整数部分</p></li><li><p><code>Number.parseFloat()</code> : 返回转换值的浮点数部分</p></li><li><p><code>Number.isFinite()</code> : 是否为有限数值</p></li><li><p><code>Number.isNaN()</code> : 是否为NaN</p></li><li><p><code>Number.isInteger()</code> : 是否为整数</p></li><li><p><code>Number.isSafeInteger()</code> : 是否在数值安全范围内</p></li><li><p><code>Math.trunc()</code> : 返回数值整数部分</p></li><li><p><code>Math.sign()</code> : 返回数值类型(<code>正数1</code>、<code>负数-1</code>、<code>零0</code>)</p></li><li><p><code>Math.cbrt()</code> : 返回数值立方根</p></li><li><p><code>Math.clz32()</code> : 返回数值的32位无符号整数形式</p></li><li><p><code>Math.imul()</code> : 返回两个数值相乘</p></li><li><p><code>Math.fround()</code> : 返回数值的32位单精度浮点数形式</p></li><li><p><code>Math.hypot()</code> : 返回所有数值平方和的平方根</p></li><li><p><code>Math.expm1()</code> : 返回<code>e^n - 1</code></p></li><li><p><code>Math.log1p()</code> : 返回<code>1 + n</code>的自然对数(<code>Math.log(1 + n)</code>)</p></li><li><p><code>Math.log10()</code> : 返回以10为底的n的对数</p></li><li><p><code>Math.log2()</code> : 返回以2为底的n的对数</p></li><li><p><code>Math.sinh()</code> : 返回n的双曲正弦</p></li><li><p><code>Math.cosh()</code> : 返回n的双曲余弦</p></li><li><p><code>Math.tanh()</code> : 返回n的双曲正切</p></li><li><p><code>Math.asinh()</code> : 返回n的反双曲正弦</p></li><li><p><code>Math.acosh()</code> : 返回n的反双曲余弦</p></li><li><p><code>Math.atanh()</code> : 返回n的反双曲正切</p></li></ul><h3 id="array对象的扩展" tabindex="-1">Array对象的扩展 <a class="header-anchor" href="#array对象的扩展" aria-label="Permalink to &quot;Array对象的扩展&quot;">​</a></h3><ul><li><p><code>Array.prototype.from</code>：转换具有<code>Iterator接口</code>的数据结构为真正数组，返回新数组。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>console.log(Array.from(&#39;foo&#39;)) // [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]</span></span>
<span class="line"><span>console.log(Array.from([1, 2, 3], x =&gt; x + x)) // [2, 4, 6]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li><li><p><code>Array.prototype.of()</code>：转换一组值为真正数组，返回新数组。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Array.of(7)       // [7] </span></span>
<span class="line"><span>Array.of(1, 2, 3) // [1, 2, 3]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Array(7)          // [empty, empty, empty, empty, empty, empty]</span></span>
<span class="line"><span>Array(1, 2, 3)    // [1, 2, 3]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li><li><p><code>Array.prototype.copyWithin()</code>：把指定位置的成员复制到其他位置，返回原数组</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(array1.copyWithin(0, 3, 4)) // [&quot;d&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(array1.copyWithin(1, 3)) // [&quot;d&quot;, &quot;d&quot;, &quot;e&quot;, &quot;d&quot;, &quot;e&quot;]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li><li><p><code>Array.prototype.find()</code>：返回第一个符合条件的成员</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const array1 = [5, 12, 8, 130, 44]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const found = array1.find(element =&gt; element &gt; 10)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(found) // 12</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li><li><p><code>Array.prototype.findIndex()</code>：返回第一个符合条件的成员索引值</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const array1 = [5, 12, 8, 130, 44]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const isLargeNumber = (element) =&gt; element &gt; 13</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(array1.findIndex(isLargeNumber)) // 3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li><li><p><code>Array.prototype.fill()</code>：根据指定值填充整个数组，返回原数组</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const array1 = [1, 2, 3, 4]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(array1.fill(0, 2, 4)) // [1, 2, 0, 0]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(array1.fill(5, 1)) // [1, 5, 5, 5]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(array1.fill(6)) // [6, 6, 6, 6]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li><li><p><code>Array.prototype.keys()</code>：返回以索引值为遍历器的对象</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span></span>
<span class="line"><span>const iterator = array1.keys()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>for (const key of iterator) {</span></span>
<span class="line"><span>      console.log(key)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 0</span></span>
<span class="line"><span>// 1</span></span>
<span class="line"><span>// 2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li><li><p><code>Array.prototype.values()</code>：返回以属性值为遍历器的对象</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span></span>
<span class="line"><span>const iterator = array1.values()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>for (const key of iterator) {</span></span>
<span class="line"><span>      console.log(key)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// a</span></span>
<span class="line"><span>// b</span></span>
<span class="line"><span>// c</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li><li><p><code>Array.prototype.entries()</code>：返回以索引值和属性值为遍历器的对象</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span></span>
<span class="line"><span>const iterator = array1.entries()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(iterator.next().value) // [0, &quot;a&quot;]</span></span>
<span class="line"><span>console.log(iterator.next().value) // [1, &quot;b&quot;]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li><li><p><code>数组空位</code>：ES6明确将数组空位转为<code>undefined</code>或者<code>empty</code></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Array.from([&#39;a&#39;,,&#39;b&#39;]) // [ &quot;a&quot;, undefined, &quot;b&quot; ]</span></span>
<span class="line"><span>[...[&#39;a&#39;,,&#39;b&#39;]] // [ &quot;a&quot;, undefined, &quot;b&quot; ]</span></span>
<span class="line"><span>Array(3) //  [empty × 3]</span></span>
<span class="line"><span>[,&#39;a&#39;] // [empty, &quot;a&quot;]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li></ul><h2 id="es7-es2016" tabindex="-1">ES7(ES2016) <a class="header-anchor" href="#es7-es2016" aria-label="Permalink to &quot;ES7(ES2016)&quot;">​</a></h2><h3 id="array-prototype-includes" tabindex="-1">Array.prototype.includes() <a class="header-anchor" href="#array-prototype-includes" aria-label="Permalink to &quot;Array.prototype.includes()&quot;">​</a></h3><p><code>includes()</code> 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p><p>代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const array1 = [1, 2, 3]</span></span>
<span class="line"><span>console.log(array1.includes(2)) // true</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const pets = [&#39;cat&#39;, &#39;dog&#39;, &#39;bat&#39;]</span></span>
<span class="line"><span>console.log(pets.includes(&#39;cat&#39;)) // true</span></span>
<span class="line"><span>console.log(pets.includes(&#39;at&#39;)) // false</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="幂运算符" tabindex="-1">幂运算符** <a class="header-anchor" href="#幂运算符" aria-label="Permalink to &quot;幂运算符\\*\\*&quot;">​</a></h3><p>幂运算符**，具有与Math.pow()一样的功能，代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>console.log(2**10) // 1024</span></span>
<span class="line"><span>console.log(Math.pow(2, 10)) // 1024</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="模板字符串-template-string-1" tabindex="-1">模板字符串（Template string） <a class="header-anchor" href="#模板字符串-template-string-1" aria-label="Permalink to &quot;模板字符串（Template string）&quot;">​</a></h3><p>自ES7起，带标签的模版字面量遵守以下转义序列的规则：</p><ul><li>Unicode字符以&quot;\\u&quot;开头，例如<code>\\u00A9</code></li><li>Unicode码位用&quot;\\u{}&quot;表示，例如<code>\\u{2F804}</code></li><li>十六进制以&quot;\\x&quot;开头，例如<code>\\xA9</code></li><li>八进制以&quot;&quot;和数字开头，例如<code>\\251</code></li></ul><p>这表示类似下面这种带标签的模版是有问题的，因为对于每一个ECMAScript语法，解析器都会去查找有效的转义序列，但是只能得到这是一个形式错误的语法：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>latex\`\\unicode\`</span></span>
<span class="line"><span>// 在较老的ECMAScript版本中报错（ES2016及更早）</span></span>
<span class="line"><span>// SyntaxError: malformed Unicode character escape sequence</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="es8-es2017" tabindex="-1">ES8(ES2017) <a class="header-anchor" href="#es8-es2017" aria-label="Permalink to &quot;ES8(ES2017)&quot;">​</a></h2><h3 id="async-await" tabindex="-1">async/await <a class="header-anchor" href="#async-await" aria-label="Permalink to &quot;async/await&quot;">​</a></h3><p>虽然<code>Promise</code>可以解决回调地狱的问题，但是链式调用太多，则会变成另一种形式的回调地狱 —— 面条地狱，所以在ES8里则出现了<code>Promise</code>的语法糖<code>async/await</code>，专门解决这个问题。</p><p>我们先看一下下面的<code>Promise</code>代码：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>fetch(&#39;coffee.jpg&#39;)</span></span>
<span class="line"><span>    .then(response =&gt; response.blob())</span></span>
<span class="line"><span>    .then(myBlob =&gt; {</span></span>
<span class="line"><span>          let objectURL = URL.createObjectURL(myBlob)</span></span>
<span class="line"><span>          let image = document.createElement(&#39;img&#39;)</span></span>
<span class="line"><span>          image.src = objectURL</span></span>
<span class="line"><span>          document.body.appendChild(image)</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>    .catch(e =&gt; {</span></span>
<span class="line"><span>          console.log(&#39;There has been a problem with your fetch operation: &#39; + e.message)</span></span>
<span class="line"><span>    })</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>然后再看看<code>async/await</code>版的，这样看起来是不是更清晰了。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>async function myFetch() {</span></span>
<span class="line"><span>      let response = await fetch(&#39;coffee.jpg&#39;)</span></span>
<span class="line"><span>      let myBlob = await response.blob()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      let objectURL = URL.createObjectURL(myBlob)</span></span>
<span class="line"><span>      let image = document.createElement(&#39;img&#39;)</span></span>
<span class="line"><span>      image.src = objectURL</span></span>
<span class="line"><span>      document.body.appendChild(image)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>myFetch()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>当然，如果你喜欢，你甚至可以两者混用</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>async function myFetch() {</span></span>
<span class="line"><span>      let response = await fetch(&#39;coffee.jpg&#39;)</span></span>
<span class="line"><span>      return await response.blob()</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>myFetch().then((blob) =&gt; {</span></span>
<span class="line"><span>      let objectURL = URL.createObjectURL(blob)</span></span>
<span class="line"><span>      let image = document.createElement(&#39;img&#39;)</span></span>
<span class="line"><span>      image.src = objectURL</span></span>
<span class="line"><span>      document.body.appendChild(image)</span></span>
<span class="line"><span>})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="object-values" tabindex="-1">Object.values() <a class="header-anchor" href="#object-values" aria-label="Permalink to &quot;Object.values()&quot;">​</a></h3><p><code>Object.values()</code>方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。</p><p>代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const object1 = {</span></span>
<span class="line"><span>      a: &#39;somestring&#39;,</span></span>
<span class="line"><span>      b: 42,</span></span>
<span class="line"><span>      c: false</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>console.log(Object.values(object1)) // [&quot;somestring&quot;, 42, false]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="object-entries" tabindex="-1">Object.entries() <a class="header-anchor" href="#object-entries" aria-label="Permalink to &quot;Object.entries()&quot;">​</a></h3><p><code>Object.entries()</code>方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。</p><p>代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const object1 = {</span></span>
<span class="line"><span>      a: &#39;somestring&#39;,</span></span>
<span class="line"><span>      b: 42</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>for (let [key, value] of Object.entries(object1)) {</span></span>
<span class="line"><span>      console.log(\`\${key}: \${value}\`)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// &quot;a: somestring&quot;</span></span>
<span class="line"><span>// &quot;b: 42&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="padstart" tabindex="-1">padStart() <a class="header-anchor" href="#padstart" aria-label="Permalink to &quot;padStart()&quot;">​</a></h3><p><code>padStart()</code> 方法用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的。</p><p>代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const str1 = &#39;5&#39;</span></span>
<span class="line"><span>console.log(str1.padStart(2, &#39;0&#39;)) // &quot;05&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const fullNumber = &#39;2034399002125581&#39;</span></span>
<span class="line"><span>const last4Digits = fullNumber.slice(-4)</span></span>
<span class="line"><span>const maskedNumber = last4Digits.padStart(fullNumber.length, &#39;*&#39;) </span></span>
<span class="line"><span>console.log(maskedNumber) // &quot;************5581&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="padend" tabindex="-1">padEnd() <a class="header-anchor" href="#padend" aria-label="Permalink to &quot;padEnd()&quot;">​</a></h3><p><code>padEnd()</code> 方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const str1 = &#39;Breaded Mushrooms&#39;</span></span>
<span class="line"><span>console.log(str1.padEnd(25, &#39;.&#39;)) // &quot;Breaded Mushrooms........&quot;</span></span>
<span class="line"><span>const str2 = &#39;200&#39;</span></span>
<span class="line"><span>console.log(str2.padEnd(5)) // &quot;200  &quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="函数参数结尾逗号-function-parameter-lists-and-calls-trailing-commas" tabindex="-1">函数参数结尾逗号（Function parameter lists and calls trailing commas） <a class="header-anchor" href="#函数参数结尾逗号-function-parameter-lists-and-calls-trailing-commas" aria-label="Permalink to &quot;函数参数结尾逗号（Function parameter lists and calls trailing commas）&quot;">​</a></h3><p>在ES5里就添加了对象的尾逗号，不过并不支持函数参数，但是在ES8之后，便开始支持这一特性，代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 参数定义</span></span>
<span class="line"><span>function f(p) {}</span></span>
<span class="line"><span>function f(p,) {} </span></span>
<span class="line"><span></span></span>
<span class="line"><span>(p) =&gt; {}</span></span>
<span class="line"><span>(p,) =&gt; {}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class C {</span></span>
<span class="line"><span>  one(a,) {},</span></span>
<span class="line"><span>  two(a, b,) {},</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var obj = {</span></span>
<span class="line"><span>  one(a,) {},</span></span>
<span class="line"><span>  two(a, b,) {},</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 函数调用</span></span>
<span class="line"><span>f(p)</span></span>
<span class="line"><span>f(p,)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Math.max(10, 20)</span></span>
<span class="line"><span>Math.max(10, 20,)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>但是以下的方式是不合法的：</p><p>仅仅包含逗号的函数参数定义或者函数调用会抛出 SyntaxError。 而且，当使用剩余参数的时候，并不支持尾后逗号，例子如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function f(,) {} // SyntaxError: missing formal parameter</span></span>
<span class="line"><span>(,) =&gt; {}       // SyntaxError: expected expression, got &#39;,&#39;</span></span>
<span class="line"><span>f(,)             // SyntaxError: expected expression, got &#39;,&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function f(...p,) {} // SyntaxError: parameter after rest parameter</span></span>
<span class="line"><span>(...p,) =&gt; {}        // SyntaxError: expected closing parenthesis, got &#39;,&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在解构里也可以使用，代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 带有尾后逗号的数组解构</span></span>
<span class="line"><span>[a, b,] = [1, 2]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 带有尾后逗号的对象解构</span></span>
<span class="line"><span>var o = {</span></span>
<span class="line"><span>  p: 42, </span></span>
<span class="line"><span>  q: true,</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var {p, q,} = o</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>同样地，在使用剩余参数时，会抛出 SyntaxError，代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var [a, ...b,] = [1, 2, 3] // SyntaxError: rest element may not have a trailing comma</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="sharearraybuffer-因安全问题-暂时在chrome跟firefox中被禁用" tabindex="-1">ShareArrayBuffer（因安全问题，暂时在Chrome跟FireFox中被禁用） <a class="header-anchor" href="#sharearraybuffer-因安全问题-暂时在chrome跟firefox中被禁用" aria-label="Permalink to &quot;ShareArrayBuffer（因安全问题，暂时在Chrome跟FireFox中被禁用）&quot;">​</a></h3><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。</p><p>代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let sab = new SharedArrayBuffer(1024) // 必须实例化</span></span>
<span class="line"><span>worker.postMessage(sab)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="atomics对象" tabindex="-1">Atomics对象 <a class="header-anchor" href="#atomics对象" aria-label="Permalink to &quot;Atomics对象&quot;">​</a></h3><p><strong>Atomics对象</strong> 提供了一组静态方法用来对 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FSharedArrayBuffer" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer" target="_blank" rel="noreferrer"><code>SharedArrayBuffer</code></a> 对象进行原子操作。</p><p>方法如下：</p><ul><li><p><strong>Atomics.add()</strong> ：将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值。</p></li><li><p><strong>Atomics.and()</strong>：将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。</p></li><li><p><strong>Atomics.compareExchange()</strong>：如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。</p></li><li><p><strong>Atomics.exchange()</strong>：将数组中指定的元素更新为给定的值，并返回该元素更新前的值。</p></li><li><p><strong>Atomics.load()</strong>：返回数组中指定元素的值。</p></li><li><p><strong>Atomics.or()</strong>：将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。</p></li><li><p><strong>Atomics.store()</strong>：将数组中指定的元素设置为给定的值，并返回该值。</p></li><li><p><strong>Atomics.sub()</strong>：将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。</p></li><li><p><strong>Atomics.xor()</strong>：将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。</p></li><li><p><strong>Atomics.wait()</strong>：检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 &quot;ok&quot;、&quot;not-equal&quot; 或 &quot;time-out&quot;。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。</p></li><li><p><strong>Atomics.wake()</strong>：唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。</p></li><li><p><strong>Atomics.isLockFree(size)</strong>：可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此函数面向的是技术专家。</p></li></ul><h3 id="object-getownpropertydescriptors" tabindex="-1">Object.getOwnPropertyDescriptors() <a class="header-anchor" href="#object-getownpropertydescriptors" aria-label="Permalink to &quot;Object.getOwnPropertyDescriptors()&quot;">​</a></h3><p><code>Object.getOwnPropertyDescriptors()</code> 方法用来获取一个对象的所有自身属性的描述符。代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const object1 = {</span></span>
<span class="line"><span>  property1: 42</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const descriptors1 = Object.getOwnPropertyDescriptors(object1)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(descriptors1.property1.writable) // true</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(descriptors1.property1.value) // 42</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 浅拷贝一个对象</span></span>
<span class="line"><span>Object.create(</span></span>
<span class="line"><span>  Object.getPrototypeOf(obj), </span></span>
<span class="line"><span>  Object.getOwnPropertyDescriptors(obj) </span></span>
<span class="line"><span>)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 创建子类</span></span>
<span class="line"><span>function superclass() {}</span></span>
<span class="line"><span>superclass.prototype = {</span></span>
<span class="line"><span>  // 在这里定义方法和属性</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>function subclass() {}</span></span>
<span class="line"><span>subclass.prototype = Object.create(superclass.prototype, Object.getOwnPropertyDescriptors({</span></span>
<span class="line"><span>  // 在这里定义方法和属性</span></span>
<span class="line"><span>}))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h2 id="es9-es2018" tabindex="-1">ES9(ES2018) <a class="header-anchor" href="#es9-es2018" aria-label="Permalink to &quot;ES9(ES2018)&quot;">​</a></h2><h3 id="for-await-of" tabindex="-1">for await...of <a class="header-anchor" href="#for-await-of" aria-label="Permalink to &quot;for await...of&quot;">​</a></h3><p><code>for await...of</code> 语句会在异步或者同步可迭代对象上创建一个迭代循环，包括 <code>String</code>，<code>Array</code>，<code>Array-like</code> 对象（比如<code>arguments</code> 或者<code>NodeList</code>)，<code>TypedArray</code>，<code>Map</code>， <code>Set</code>和自定义的异步或者同步可迭代对象。其会调用自定义迭代钩子，并为每个不同属性的值执行语句。</p><p>配合迭代异步生成器，例子如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>async function* asyncGenerator() {</span></span>
<span class="line"><span>      var i = 0</span></span>
<span class="line"><span>      while (i &lt; 3) {</span></span>
<span class="line"><span>            yield i++</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>(async function() {</span></span>
<span class="line"><span>      for await (num of asyncGenerator()) {</span></span>
<span class="line"><span>            console.log(num)</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>})()</span></span>
<span class="line"><span>// 0</span></span>
<span class="line"><span>// 1</span></span>
<span class="line"><span>// 2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="模板字符串-template-string-2" tabindex="-1">模板字符串（Template string） <a class="header-anchor" href="#模板字符串-template-string-2" aria-label="Permalink to &quot;模板字符串（Template string）&quot;">​</a></h3><p>ES9开始，模板字符串允许嵌套支持常见转义序列，移除对ECMAScript在带标签的模版字符串中转义序列的语法限制。</p><p>不过，非法转义序列在&quot;cooked&quot;当中仍然会体现出来。它们将以<code>undefined</code>元素的形式存在于&quot;cooked&quot;之中，代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function latex(str) { </span></span>
<span class="line"><span> return { &quot;cooked&quot;: str[0], &quot;raw&quot;: str.raw[0] }</span></span>
<span class="line"><span>} </span></span>
<span class="line"><span></span></span>
<span class="line"><span>latex\`\\unicode\` // { cooked: undefined, raw: &quot;\\\\unicode&quot; }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="正则表达式反向-lookbehind-断言" tabindex="-1">正则表达式反向(lookbehind)断言 <a class="header-anchor" href="#正则表达式反向-lookbehind-断言" aria-label="Permalink to &quot;正则表达式反向(lookbehind)断言&quot;">​</a></h3><p>首先我们得先知道什么是<strong>断言(Assertion)</strong>。</p><p>**断言(Assertion)**是一个对当前匹配位置之前或之后的字符的测试， 它不会实际消耗任何字符，所以断言也被称为“非消耗性匹配”或“非获取匹配”。</p><p>正则表达式的断言一共有 4 种形式：</p><ul><li><code>(?=pattern)</code> 零宽正向肯定断言(zero-width positive lookahead assertion)</li><li><code>(?!pattern)</code> 零宽正向否定断言(zero-width negative lookahead assertion)</li><li><code>(?&lt;=pattern)</code> 零宽反向肯定断言(zero-width positive lookbehind assertion)</li><li><code>(?&lt;!pattern)</code> 零宽反向否定断言(zero-width negative lookbehind assertion)</li></ul><p>在ES9之前，JavaScript 正则表达式，只支持正向断言。正向断言的意思是：当前位置后面的字符串应该满足断言，但是并不捕获。例子如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>&#39;fishHeadfishTail&#39;.match(/fish(?=Head)/g) // [&quot;fish&quot;]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>反向断言和正向断言的行为一样，只是方向相反。例子如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>&#39;abc123&#39;.match(/(?&lt;=(\\d+)(\\d+))$/) //  [&quot;&quot;, &quot;1&quot;, &quot;23&quot;, index: 6, input: &quot;abc123&quot;, groups: undefined]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="正则表达式-unicode-转义" tabindex="-1">正则表达式 Unicode 转义 <a class="header-anchor" href="#正则表达式-unicode-转义" aria-label="Permalink to &quot;正则表达式 Unicode 转义&quot;">​</a></h3><p>正则表达式中的Unicode转义符允许根据Unicode字符属性匹配Unicode字符。 它允许区分字符类型，例如大写和小写字母，数学符号和标点符号。</p><p>部分例子代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 匹配所有数字</span></span>
<span class="line"><span>const regex = /^\\p{Number}+$/u;</span></span>
<span class="line"><span>regex.test(&#39;²³¹¼½¾&#39;) // true</span></span>
<span class="line"><span>regex.test(&#39;㉛㉜㉝&#39;) // true</span></span>
<span class="line"><span>regex.test(&#39;ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ&#39;) // true</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 匹配所有空格</span></span>
<span class="line"><span>\\p{White_Space}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 匹配各种文字的所有字母，等同于 Unicode 版的 \\w</span></span>
<span class="line"><span>[\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \\W</span></span>
<span class="line"><span>[^\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 匹配 Emoji</span></span>
<span class="line"><span>/\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}|\\p{Emoji}\\uFE0F/gu</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 匹配所有的箭头字符</span></span>
<span class="line"><span>const regexArrows = /^\\p{Block=Arrows}+$/u;</span></span>
<span class="line"><span>regexArrows.test(&#39;←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩&#39;) // true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>具体的属性列表可查看：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FRegular_Expressions%2FUnicode_Property_Escapes" title="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes" target="_blank" rel="noreferrer">developer.mozilla.org/en-US/docs/…</a></p><h3 id="正则表达式-s-dotall-模式" tabindex="-1">正则表达式 s/dotAll 模式 <a class="header-anchor" href="#正则表达式-s-dotall-模式" aria-label="Permalink to &quot;正则表达式 s/dotAll 模式&quot;">​</a></h3><p>在以往的版本里，JS的正则的<code>.</code>只能匹配emoji跟行终结符以外的所有文本，例如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>let regex = /./;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>regex.test(&#39;\\n&#39;);       // false</span></span>
<span class="line"><span>regex.test(&#39;\\r&#39;);       // false</span></span>
<span class="line"><span>regex.test(&#39;\\u{2028}&#39;); // false</span></span>
<span class="line"><span>regex.test(&#39;\\u{2029}&#39;); // false</span></span>
<span class="line"><span></span></span>
<span class="line"><span>regex.test(&#39;\\v&#39;);       // true</span></span>
<span class="line"><span>regex.test(&#39;\\f&#39;);       // true</span></span>
<span class="line"><span>regex.test(&#39;\\u{0085}&#39;); // true</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/foo.bar/.test(&#39;foo\\nbar&#39;);     // false</span></span>
<span class="line"><span>/foo[^]bar/.test(&#39;foo\\nbar&#39;);   // true</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/foo.bar/.test(&#39;foo\\nbar&#39;);     // false</span></span>
<span class="line"><span>/foo[\\s]bar/.test(&#39;foo\\nbar&#39;);   // true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>但是在ES9之后，JS正则增加了一个新的标志 <code>s</code> 用来表示 dotAll，这可以匹配任意字符。代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>/foo.bar/s.test(&#39;foo\\nbar&#39;);    // true</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const re = /foo.bar/s;  //  等价于 const re = new RegExp(&#39;foo.bar&#39;, &#39;s&#39;);</span></span>
<span class="line"><span>re.test(&#39;foo\\nbar&#39;);    // true</span></span>
<span class="line"><span>re.dotAll;      // true</span></span>
<span class="line"><span>re.flags;       // &quot;s&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="正则表达式命名捕获组" tabindex="-1">正则表达式命名捕获组 <a class="header-anchor" href="#正则表达式命名捕获组" aria-label="Permalink to &quot;正则表达式命名捕获组&quot;">​</a></h3><p>在以往的版本里，JS的正则分组是无法命名的，所以容易混淆。例如下面获取年月日的例子，很容易让人搞不清哪个是月份，哪个是年份:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const matched = /(\\d{4})-(\\d{2})-(\\d{2})/.exec(&#39;2019-01-01&#39;)</span></span>
<span class="line"><span>console.log(matched[0]);    // 2019-01-01</span></span>
<span class="line"><span>console.log(matched[1]);    // 2019</span></span>
<span class="line"><span>console.log(matched[2]);    // 01</span></span>
<span class="line"><span>console.log(matched[3]);    // 01</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>ES9引入了命名捕获组，允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const RE_DATE = /(?&lt;year&gt;\\d{4})-(?&lt;month&gt;\\d{2})-(?&lt;day&gt;\\d{2})/;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const matchObj = RE_DATE.exec(&#39;1999-12-31&#39;);</span></span>
<span class="line"><span>const year = matchObj.groups.year; // 1999</span></span>
<span class="line"><span>const month = matchObj.groups.month; // 12</span></span>
<span class="line"><span>const day = matchObj.groups.day; // 31</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const RE_OPT_A = /^(?&lt;as&gt;a+)?$/;</span></span>
<span class="line"><span>const matchObj = RE_OPT_A.exec(&#39;&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>matchObj.groups.as // undefined</span></span>
<span class="line"><span>&#39;as&#39; in matchObj.groups // true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="对象扩展操作符" tabindex="-1">对象扩展操作符 <a class="header-anchor" href="#对象扩展操作符" aria-label="Permalink to &quot;对象扩展操作符&quot;">​</a></h3><p>ES6中添加了数组的扩展操作符，让我们在操作数组时更加简便，美中不足的是并不支持对象扩展操作符，但是在ES9开始，这一功能也得到了支持，例如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var obj1 = { foo: &#39;bar&#39;, x: 42 };</span></span>
<span class="line"><span>var obj2 = { foo: &#39;baz&#39;, y: 13 };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var clonedObj = { ...obj1 };</span></span>
<span class="line"><span>// 克隆后的对象: { foo: &quot;bar&quot;, x: 42 }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>var mergedObj = { ...obj1, ...obj2 };</span></span>
<span class="line"><span>// 合并后的对象: { foo: &quot;baz&quot;, x: 42, y: 13 }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>上面便是一个简便的浅拷贝。这里有一点小提示，就是<code>Object.assign()</code> 函数会触发 <code>setters</code>，而展开语法则不会。所以不能替换也不能模拟<code>Object.assign()</code> 。</p><p>如果存在相同的属性名，只有最后一个会生效。</p><h3 id="promise-prototype-finally" tabindex="-1">Promise.prototype.finally() <a class="header-anchor" href="#promise-prototype-finally" aria-label="Permalink to &quot;Promise.prototype.finally()&quot;">​</a></h3><p><code>finally()</code>方法会返回一个<code>Promise</code>，当promise的状态变更，不管是变成<code>rejected</code>或者<code>fulfilled</code>，最终都会执行<code>finally()</code>的回调。</p><p>例子如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>fetch(url)</span></span>
<span class="line"><span>      .then((res) =&gt; {</span></span>
<span class="line"><span>        console.log(res)</span></span>
<span class="line"><span>      })</span></span>
<span class="line"><span>      .catch((error) =&gt; { </span></span>
<span class="line"><span>        console.log(error)</span></span>
<span class="line"><span>      })</span></span>
<span class="line"><span>      .finally(() =&gt; { </span></span>
<span class="line"><span>        console.log(&#39;结束&#39;)</span></span>
<span class="line"><span>    })</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="es10-es2019" tabindex="-1">ES10(ES2019) <a class="header-anchor" href="#es10-es2019" aria-label="Permalink to &quot;ES10(ES2019)&quot;">​</a></h2><h3 id="array-prototype-flat-flatmap" tabindex="-1">Array.prototype.flat() / flatMap() <a class="header-anchor" href="#array-prototype-flat-flatmap" aria-label="Permalink to &quot;Array.prototype.flat() / flatMap()&quot;">​</a></h3><p><code>flat()</code> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p><p><code>flatMap()</code>与 <code>map()</code> 方法和深度为1的 <code>flat()</code> 几乎相同.，不过它会首先使用映射函数映射每个元素，然后将结果压缩成一个新数组，这样效率会更高。</p><p>例子如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var arr1 = [1, 2, 3, 4]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>arr1.map(x =&gt; [x * 2]) // [[2], [4], [6], [8]]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>arr1.flatMap(x =&gt; [x * 2]) // [2, 4, 6, 8]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 深度为1</span></span>
<span class="line"><span>arr1.flatMap(x =&gt; [[x * 2]]) // [[2], [4], [6], [8]]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><code>flatMap()</code>可以代替<code>reduce()</code> 与 <code>concat()</code>，例子如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var arr = [1, 2, 3, 4]</span></span>
<span class="line"><span>arr.flatMap(x =&gt; [x, x * 2]) // [1, 2, 2, 4, 3, 6, 4, 8]</span></span>
<span class="line"><span>// 等价于</span></span>
<span class="line"><span>arr.reduce((acc, x) =&gt; acc.concat([x, x * 2]), []) // [1, 2, 2, 4, 3, 6, 4, 8]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>但这是非常低效的，在每次迭代中，它创建一个必须被垃圾收集的新临时数组，并且它将元素从当前的累加器数组复制到一个新的数组中，而不是将新的元素添加到现有的数组中。</p><h3 id="string-prototype-trimstart-trimleft-trimend-trimright" tabindex="-1">String.prototype.trimStart() / trimLeft() / trimEnd() / trimRight() <a class="header-anchor" href="#string-prototype-trimstart-trimleft-trimend-trimright" aria-label="Permalink to &quot;String.prototype.trimStart() / trimLeft() / trimEnd() / trimRight()&quot;">​</a></h3><p>在ES5中，我们可以通过<code>trim()</code>来去掉字符首尾的空格，但是却无法只去掉单边的，但是在ES10之后，我们可以实现这个功能。</p><p>如果我们要去掉开头的空格，可以使用<code>trimStart()</code>或者它的别名<code>trimLeft()</code>，</p><p>同样的，如果我们要去掉结尾的空格，我们可以使用<code>trimEnd()</code>或者它的别名<code>trimRight()</code>。</p><p>例子如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const Str = &#39;   Hello world!  &#39;</span></span>
<span class="line"><span>console.log(Str) // &#39;   Hello world!  &#39;</span></span>
<span class="line"><span>console.log(Str.trimStart()) // &#39;Hello world!  &#39;</span></span>
<span class="line"><span>console.log(Str.trimLeft()) // &#39;Hello world!  &#39;</span></span>
<span class="line"><span>console.log(Str.trimEnd()) // &#39;   Hello world!&#39;</span></span>
<span class="line"><span>console.log(Str.trimRight()) // &#39;   Hello world!&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>不过这里有一点要注意的是，<code>trimStart()</code>跟<code>trimEnd()</code>才是标准方法，<code>trimLeft()</code>跟<code>trimRight()</code>只是别名。</p><p>在某些引擎里（例如Chrome），有以下的等式：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>String.prototype.trimLeft.name === &quot;trimStart&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>String.prototype.trimRight.name === &quot;trimEnd&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="object-fromentries" tabindex="-1">Object.fromEntries() <a class="header-anchor" href="#object-fromentries" aria-label="Permalink to &quot;Object.fromEntries()&quot;">​</a></h3><p><code>Object.fromEntries()</code> 方法把键值对列表转换为一个对象，它是<code>Object.entries()</code>的反函数。</p><p>例子如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const entries = new Map([</span></span>
<span class="line"><span>  [&#39;foo&#39;, &#39;bar&#39;],</span></span>
<span class="line"><span>  [&#39;baz&#39;, 42]</span></span>
<span class="line"><span>])</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const obj = Object.fromEntries(entries)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(obj) // Object { foo: &quot;bar&quot;, baz: 42 }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="symbol-prototype-description" tabindex="-1">Symbol.prototype.description <a class="header-anchor" href="#symbol-prototype-description" aria-label="Permalink to &quot;Symbol.prototype.description&quot;">​</a></h3><p><code>description</code> 是一个只读属性，它会返回<code>Symbol</code>对象的可选描述的字符串。与 <code>Symbol.prototype.toString()</code> 不同的是它不会包含<code>Symbol()</code>的字符串。例子如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Symbol(&#39;desc&#39;).toString();   // &quot;Symbol(desc)&quot;</span></span>
<span class="line"><span>Symbol(&#39;desc&#39;).description;  // &quot;desc&quot;</span></span>
<span class="line"><span>Symbol(&#39;&#39;).description;      // &quot;&quot;</span></span>
<span class="line"><span>Symbol().description;        // undefined</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 具名 symbols</span></span>
<span class="line"><span>Symbol.iterator.toString();  // &quot;Symbol(Symbol.iterator)&quot;</span></span>
<span class="line"><span>Symbol.iterator.description; // &quot;Symbol.iterator&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//全局 symbols</span></span>
<span class="line"><span>Symbol.for(&#39;foo&#39;).toString();  // &quot;Symbol(foo)&quot;</span></span>
<span class="line"><span>Symbol.for(&#39;foo&#39;).description; // &quot;foo&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="string-prototype-matchall" tabindex="-1">String.prototype.matchAll <a class="header-anchor" href="#string-prototype-matchall" aria-label="Permalink to &quot;String.prototype.matchAll&quot;">​</a></h3><p><code>matchAll()</code> 方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。并且返回一个不可重启的迭代器。例子如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var regexp = /t(e)(st(\\d?))/g</span></span>
<span class="line"><span>var str = &#39;test1test2&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>str.match(regexp) // [&#39;test1&#39;, &#39;test2&#39;]</span></span>
<span class="line"><span>str.matchAll(regexp) // RegExpStringIterator {}</span></span>
<span class="line"><span>[...str.matchAll(regexp)] // [[&#39;test1&#39;, &#39;e&#39;, &#39;st1&#39;, &#39;1&#39;, index: 0, input: &#39;test1test2&#39;, length: 4], [&#39;test2&#39;, &#39;e&#39;, &#39;st2&#39;, &#39;2&#39;, index: 5, input: &#39;test1test2&#39;, length: 4]]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="function-prototype-tostring-返回注释与空格" tabindex="-1">Function.prototype.toString() 返回注释与空格 <a class="header-anchor" href="#function-prototype-tostring-返回注释与空格" aria-label="Permalink to &quot;Function.prototype.toString() 返回注释与空格&quot;">​</a></h3><p>在以往的版本中，<code>Function.prototype.toString()</code>得到的字符串是去掉空白符号的，但是从ES10开始会保留这些空格，如果是原生函数则返回你控制台看到的效果，例子如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function sum(a, b) {</span></span>
<span class="line"><span>      return a + b;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(sum.toString())</span></span>
<span class="line"><span>// &quot;function sum(a, b) {</span></span>
<span class="line"><span>//   return a + b;</span></span>
<span class="line"><span>//  }&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(Math.abs.toString()) // &quot;function abs() { [native code] }&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="try-catch" tabindex="-1">try-catch <a class="header-anchor" href="#try-catch" aria-label="Permalink to &quot;try-catch&quot;">​</a></h3><p>在以往的版本中，<code>try-catch</code>里<code>catch</code>后面必须带异常参数，例如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>    // ES10之前</span></span>
<span class="line"><span>try {</span></span>
<span class="line"><span>      // tryCode</span></span>
<span class="line"><span>} catch (err) {</span></span>
<span class="line"><span>      // catchCode</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>但是在ES10之后，这个参数却不是必须的，如果用不到，我们可以不用传，例如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>try {</span></span>
<span class="line"><span>      console.log(&#39;Foobar&#39;)</span></span>
<span class="line"><span>} catch {</span></span>
<span class="line"><span>      console.error(&#39;Bar&#39;)</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="bigint" tabindex="-1">BigInt <a class="header-anchor" href="#bigint" aria-label="Permalink to &quot;BigInt&quot;">​</a></h3><p><strong>BigInt</strong> 是一种内置对象，它提供了一种方法来表示大于 <code>253 - 1</code> 的整数。这原本是 Javascript中可以用 <code>Number</code> 表示的最大数字。<strong>BigInt</strong> 可以表示任意大的整数。</p><p>可以用在一个整数字面量后面加 <code>n</code> 的方式定义一个 <code>BigInt</code> ，如：<code>10n</code>，或者调用函数<code>BigInt()</code>。</p><p>在以往的版本中，我们有以下的弊端：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 大于2的53次方的整数，无法保持精度</span></span>
<span class="line"><span>2 ** 53 === (2 ** 53 + 1)</span></span>
<span class="line"><span>// 超过2的1024次方的数值，无法表示</span></span>
<span class="line"><span>2 ** 1024 // Infinity</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>但是在ES10引入<code>BigInt</code>之后，这个问题便得到了解决。</p><p>以下操作符可以和 <code>BigInt</code> 一起使用： <code>+</code>、<code>*</code>、<code>-</code>、<code>**</code>、<code>%</code> 。除 <code>&gt;&gt;&gt;</code> （无符号右移）之外的位操作也可以支持。因为 <code>BigInt</code> 都是有符号的， <code>&gt;&gt;&gt;</code> （无符号右移）不能用于 <code>BigInt</code>。<code>BigInt</code> 不支持单目 (<code>+</code>) 运算符。</p><p><code>/</code> 操作符对于整数的运算也没问题。可是因为这些变量是 <code>BigInt</code> 而不是 <code>BigDecimal</code> ，该操作符结果会向零取整，也就是说不会返回小数部分。</p><p><code>BigInt</code> 和 <code>Number</code>不是严格相等的，但是宽松相等的。</p><p>所以在<code>BigInt</code>出来以后，JS的原始类型便增加到了7个，如下：</p><ul><li>Boolean</li><li>Null</li><li>Undefined</li><li>Number</li><li>String</li><li>Symbol (ES6)</li><li>BigInt (ES10)</li></ul><h3 id="globalthis" tabindex="-1">globalThis <a class="header-anchor" href="#globalthis" aria-label="Permalink to &quot;globalThis&quot;">​</a></h3><p><code>globalThis</code>属性包含类似于全局对象 <code>this</code>值。所以在全局环境下，我们有：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>globalThis === this // true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="import-语句" tabindex="-1">import 语句 <a class="header-anchor" href="#import-语句" aria-label="Permalink to &quot;import 语句&quot;">​</a></h3><p>静态的 import 语句用于导入由另一个模块导出的绑定。无论是否声明了 严格模式，导入的模块都运行在严格模式下。在浏览器中，import 语句只能在声明了 type=&quot;module 的 script 的标签中使用。</p><p>但是在ES10之后，我们有动态 import()，它不需要依赖 type=&quot;module 的script标签。</p><p>所以我们有以下例子：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> main</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;main&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> link</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelectorAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;nav &gt; a&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      link.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;click&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">preventDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/modules/my-module.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">module</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">                    module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">loadPageInto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(main);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    main.textContent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err.message;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="私有元素与方法" tabindex="-1">私有元素与方法 <a class="header-anchor" href="#私有元素与方法" aria-label="Permalink to &quot;私有元素与方法&quot;">​</a></h3><p>在ES10之前，如果我们要实现一个简单的计数器组件，我们可能会这么写：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// web component 写法</span></span>
<span class="line"><span>class Counter extends HTMLElement {</span></span>
<span class="line"><span>      get x() { </span></span>
<span class="line"><span>           return this.xValue</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>      set x(value) {</span></span>
<span class="line"><span>              this.xValue = value</span></span>
<span class="line"><span>              window.requestAnimationFrame(this.render.bind(this))</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      clicked() {</span></span>
<span class="line"><span>            this.x++</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      constructor() {</span></span>
<span class="line"><span>            super()</span></span>
<span class="line"><span>            this.onclick = this.clicked.bind(this)</span></span>
<span class="line"><span>            this.xValue = 0</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      connectedCallback() { </span></span>
<span class="line"><span>           this.render()</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      render() {</span></span>
<span class="line"><span>            this.textContent = this.x.toString()</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>window.customElements.define(&#39;num-counter&#39;, Counter)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>但是在ES10之后我们可以使用私有变量进行组件封装，如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class Counter extends HTMLElement {</span></span>
<span class="line"><span>      #xValue = 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      get #x() { </span></span>
<span class="line"><span>          return #xValue</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>      set #x(value) {</span></span>
<span class="line"><span>            this.#xValue = value</span></span>
<span class="line"><span>            window.requestAnimationFrame(this.#render.bind(this))</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      #clicked() {</span></span>
<span class="line"><span>            this.#x++</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      constructor() {</span></span>
<span class="line"><span>            super();</span></span>
<span class="line"><span>            this.onclick = this.#clicked.bind(this)</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      connectedCallback() { </span></span>
<span class="line"><span>           this.#render()</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      #render() {</span></span>
<span class="line"><span>            this.textContent = this.#x.toString()</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>window.customElements.define(&#39;num-counter&#39;, Counter)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div>`,290);function m(h,g,v,k,y,f){const e=a("ArticleMetadata"),p=a("ClientOnly");return i(),r("div",null,[d,s(p,null,{default:t(()=>[s(e)]),_:1}),u])}const C=l(b,[["render",m]]);export{q as __pageData,C as default};
