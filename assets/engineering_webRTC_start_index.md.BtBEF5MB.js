import{_ as e,o as l,c as t,J as s,w as r,m as a,a as c,aa as h,E as n}from"./chunks/framework.DJCjJe2w.js";const C=JSON.parse('{"title":"WebRTC 的应用场景","description":"","frontmatter":{"createTime":"2022/11/14","tag":"工程化,WebRTC","userName":"荣顶","link":"https://github.com/wangrongding"},"headers":[],"relativePath":"engineering/webRTC/start/index.md","filePath":"engineering/webRTC/start/index.md","lastUpdated":1668392055000}'),k={name:"engineering/webRTC/start/index.md"},d=a("h1",{id:"webrtc-的应用场景",tabindex:"-1"},[c("WebRTC 的应用场景 "),a("a",{class:"header-anchor",href:"#webrtc-的应用场景","aria-label":'Permalink to "WebRTC 的应用场景"'},"​")],-1),b=h(`<hr><p><code>WebRTC</code> (Web Real-Time Communications) 是一项<code>实时通讯技术</code>，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间<code>点对点（Peer-to-Peer）的连接</code>，实现视频流和（或）音频流或者其他<code>任意数据</code>的传输。WebRTC 包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。</p><h2 id="webrtc-的应用场景-1" tabindex="-1">WebRTC 的应用场景 <a class="header-anchor" href="#webrtc-的应用场景-1" aria-label="Permalink to &quot;WebRTC 的应用场景&quot;">​</a></h2><ul><li>直播</li><li>游戏</li><li>视频会议/在线教育</li><li>屏幕共享/远程控制</li><li>等等等</li></ul><p>可玩性很强，可以做很多有趣的事情。（哪怕是被玩烂了概念“元宇宙”😂） 在网速与硬件越来越好的趋势下，WebRTC 它有无限可能。</p><h2 id="媒体流" tabindex="-1">媒体流 <a class="header-anchor" href="#媒体流" aria-label="Permalink to &quot;媒体流&quot;">​</a></h2><p>要想了解 WebRTC，首先要了解媒体流，媒体流可以是来自本地设备的，也可以是来自远程设备的。媒体流可以是实时的，也可以是非实时的。上述的应用场景中，我们都需要使用到<code>媒体流</code>，我们可以通过摄像头，麦克风，屏幕共享等方式获取到媒体流，然后通过 WebRTC 技术将媒体流传输到远端实现实时通讯。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7154cbc6b15046e499766463a5f09ece~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><h2 id="摄像头获取媒体流及一些其他操作" tabindex="-1">摄像头获取媒体流及一些其他操作 <a class="header-anchor" href="#摄像头获取媒体流及一些其他操作" aria-label="Permalink to &quot;摄像头获取媒体流及一些其他操作&quot;">​</a></h2><p>要实现 音视频通话，我们肯定要先获取到摄像头的媒体流，然后通过 WebRTC 技术将媒体流传输到远端实现实时通讯。下面我们先通过一个简单的拍照小应用来看一下如何通过摄像头获取媒体流。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/508858e1fe87430085afc372da7764c1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><p>先设置好用于播放媒体流的 video 标签，添加一个 autoplay 属性，这样就可以在摄像头获取到媒体流后自动播放了。</p><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">video</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;localVideo&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> autoplay</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> playsinline</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> muted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">video</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><strong>需要注意的是，WebRTC 只能在 HTTPS 协议或者 localhost 下使用，如果是 HTTP 协议，会报错。</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65a5f0333ef04eb1a07bd7690df13f00~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><p>这里我们暂时使用 localhost 做简单的演示，后面通过<code>信令服务器</code>实现实时音视频的章节我会讲到如何在本地用 <code>mkcert</code> 做自签名证书。</p><p>ok, continue ~</p><p>我们主要通过<code>navigator.mediaDevices.getUserMedia(constraints)</code>这个 api 来获取媒体流，这个方法接收一个配置对象作为参数，配置对象中包含了媒体流的类型，以及媒体流的分辨率等信息。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取本地音视频流</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getLocalStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">constraints</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MediaStreamConstraints</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 获取媒体流</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> stream</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator.mediaDevices.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getUserMedia</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(constraints)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>其中<code>constraints</code>指定了请求的媒体类型和相对应的参数，用于配置视频流和音频流的信息。</p><p>我可以看下<code>constraints</code>参数中具体支持哪些配置项，可以通过<code>navigator.mediaDevices.getSupportedConstraints()</code>这个方法来获取。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;🚀🚀🚀 / SupportedConstraints&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  navigator.mediaDevices.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getSupportedConstraints</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>我们把它打印出来，可以看到它支持的配置项有：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/187ee4a65126482abda0759a8a40e4fc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><p>通常我们不设置<code>constraints</code>参数，那么默认就是获取摄像头和麦克风的媒体流，如果我们只想要获取摄像头的媒体流，那么我们可以这样设置：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">navigator.mediaDevices.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getUserMedia</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  audio: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  video: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果我们想要获取视频的高度宽度，那么我们可以这样设置：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">navigator.mediaDevices.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getUserMedia</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  audio: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  video: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    width: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1280</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    height: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">720</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>诸如此类，video 中也可以设置设备 id 或者前后置摄像头...， 大家可以在支持的情况下根据自己的需求来设置即可。具体可以查看<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FMediaDevices%2FgetUserMedia" title="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getUserMedia" target="_blank" rel="noreferrer">MDN</a>。这里我不做过多的介绍了，我们继续。</p><p>获取通过摄像头获取媒体流后，将媒体流赋值给 video 标签的 srcObject 属性，让其播放。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取本地音视频流</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getLocalStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">constraints</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MediaStreamConstraints</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 获取媒体流</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> stream</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator.mediaDevices.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getUserMedia</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(constraints)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 将媒体流设置到 video 标签上播放</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  playLocalStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stream)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 播放本地视频流</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> playLocalStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">stream</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MediaStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> videoEl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;localVideo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HTMLVideoElement</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  videoEl.srcObject </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stream</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getLocalStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  audio: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  video: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>实现拍照功能，canvas 标签可以将媒体流绘制到 canvas 上，也可以通过 toDataURL 方法将 canvas 转换为 base64 图片后做一些其他操作。</p><p>附上一个 👉 <a href="https://link.juejin.cn/?target=https%3A%2F%2Ffrontend-park.vercel.app%2Faudio-and-video%2FwebRTC%2Ftake-photos" title="https://frontend-park.vercel.app/audio-and-video/webRTC/take-photos" target="_blank" rel="noreferrer">体验地址</a></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87ce1c50fce64c75aacb220014d3d52e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">video</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;localVideo&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> autoplay</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> playsinline</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> muted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">video</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-for</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;(item,index) in imgList.length&quot;</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> :key=&quot;index&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;item&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">img</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> :src=&quot;item&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> alt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>我们通过获取已经在播放媒体流的 video 标签，然后将其绘制到 canvas 上，再通过 toDataURL 方法将 canvas 转换为 base64 图片。</p><p>这里你可以加一些滤镜或者加一些美颜功能或是其他的操作，最终生成的 imgUrl 给到 img 标签让其展示就行了。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 拍照</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> takePhoto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> videoEl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;localVideo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HTMLVideoElement</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> canvas</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;canvas&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  canvas.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> videoEl.videoWidth</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  canvas.height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> videoEl.videoHeight</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ctx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> canvas.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;2d&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">drawImage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(videoEl, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, canvas.width, canvas.height)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  imgList.value.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(canvas.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toDataURL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;image/png&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;🚀🚀🚀 / imgList&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, imgList)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 添加滤镜</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> filterList</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;blur(5px)&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 模糊</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;brightness(0.5)&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 亮度</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;contrast(200%)&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 对比度</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;grayscale(100%)&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 灰度</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;hue-rotate(90deg)&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 色相旋转</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;invert(100%)&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 反色</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;opacity(90%)&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 透明度</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;saturate(200%)&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 饱和度</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;saturate(20%)&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 饱和度</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;sepia(100%)&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 褐色</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;drop-shadow(4px 4px 8px blue)&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 阴影</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filterList.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ctx.filter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filterList[i]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">drawImage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(videoEl, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, canvas.width, canvas.height)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    imgList.value.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(canvas.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toDataURL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;image/png&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>拍摄的时候我们也可以切换摄像头，这里我们通过调用 <code>navigator.mediaDevices.enumerateDevices</code> 方法，获取到所有的设备，然后筛选出 videoinput 类型的设备，最后通过不同的设备 id 来实现切换摄像头。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取所有视频输入设备</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getDevices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> devices</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator.mediaDevices.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">enumerateDevices</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;🚀🚀🚀 / devices&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, devices)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> videoDevices </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> devices.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">device</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> device.kind </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;videoinput&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 切换设备</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleDeviceChange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">deviceId</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  getLocalStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> stream</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator.mediaDevices.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getUserMedia</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    audio: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    video: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      deviceId: { exact: deviceId },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这里我们把获取到的设备列表信息打印看看，我们可以看到每个设备都有一个 deviceId，我们就是通过这个 id 来切换设备的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4016821b03214f5a9f35a19767fc6fe2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><p>可以看到，获得了多个摄像头设备，我这里是一个笔记本自带的摄像头和一个 OBS 虚拟摄像头，包括最近 MacOs 更新到 Ventura 13 ,IOS 更新到 16 后的<code>连续互通摄像头</code>，都可以获取到。这样我们就可以在视频的时候，就可以通过拍摄更清晰的手机后置来拍摄了。</p><p>虚拟摄像头更有意思，在 OBS 中开启虚拟摄像头后，可以播放一个视频，然后进行视频会议，这样你甚至可以提前录制好一个端坐的视频（简直是上网课必备！😅），我之前试过播放特朗普的视频，然后微信视频，对面看到的确实是特朗普在演讲，所以说这方面很有安全隐患，所以大家在网上和别人视频的时候，还是需要注意下，对方可能不是真的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35e6428b3c76425094067f3a88f0c08c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07e694f9c95c423c99492b8ceaaffb47~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7dca829c42944e2a45b4b017d0070a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><p>跑题了，我们继续。🦄🦄🦄</p><p>说完了切换摄像头，我们再来看看如何在支持切换前后置摄像头的设备上如何切换前后摄像头。我们可以通过指定 <code>facingMode</code> 来实现，facingMode 有 4 个值，分别是 user、environment 和 left、right，分别对应前后摄像头和左右摄像头。</p><p>当需要强制使用前置摄像头时，可以使用 exact 关键字，例如 facingMode: { exact: &#39;user&#39; }，强制切换前后摄像头时，当摄像头不支持时，会报一个 OverconstrainedError［无法满足要求的错误］<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/779e8bb4fc7a47a29c05327ada434290~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 切换前后摄像头</span></span>
<span class="line"><span>function switchCamera(val: number) {</span></span>
<span class="line"><span>  let constraints = {</span></span>
<span class="line"><span>    video: true, // 开启默认摄像头</span></span>
<span class="line"><span>    audio: true,</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  constraints.video = {</span></span>
<span class="line"><span>    // 强制切换前后摄像头时，当摄像头不支持时，会报一个OverconstrainedError［无法满足要求的错误］</span></span>
<span class="line"><span>    facingMode: { exact: val === 1 ? &#39;user&#39; : &#39;environment&#39; },</span></span>
<span class="line"><span>    // 也可以这样当前后摄像头不支持切换时，会继续使用当前摄像头，好处是不会报错</span></span>
<span class="line"><span>    // facingMode: val === 1 ? &#39;user&#39; : &#39;environment&#39;,</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  navigator.mediaDevices</span></span>
<span class="line"><span>    .getUserMedia(constraints)</span></span>
<span class="line"><span>    .then((stream) =&gt; {</span></span>
<span class="line"><span>      ElMessage.success(&#39;切换成功&#39;)</span></span>
<span class="line"><span>      playLocalStream(stream)</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>    .catch((err) =&gt; {</span></span>
<span class="line"><span>      ElMessage.error(&#39;你的设备不支持切换前后摄像头&#39;)</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>switchCamera(1) // 切换前置摄像头</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f70b6a6b5be4faaa84f14442603faa5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><p>通过这个简单的拍照小应用，相信我们已经知道了通过摄像头获取媒体流的大概流程以及一些常用的 API 了。</p><p>ok, continue ~</p><h2 id="通过屏幕共享获取获取媒体流-实现录制等操作" tabindex="-1">通过屏幕共享获取获取媒体流，实现录制等操作 <a class="header-anchor" href="#通过屏幕共享获取获取媒体流-实现录制等操作" aria-label="Permalink to &quot;通过屏幕共享获取获取媒体流，实现录制等操作&quot;">​</a></h2><p>在视频会议中，我们经常会使用到屏幕共享，已经我们经常会有录制屏幕等需求，市面上还有那么多需要付费的软件，我们通过 WebRTC 配合一些相关 api 自己实现一个不是更好吗？🤔🤔🤔 既省钱又学到了知识。</p><p>那么我们如何通过屏幕共享获取媒体流并实现录制呢？下面通过一个小 demo 来简单实现一下。</p><p>在 WebRTC 中，我们可以通过 <code>getDisplayMedia</code> 来获取屏幕共享的媒体流，这个 API 与 <code>getUserMedia</code> 类似，但是它只能获取屏幕共享的媒体流。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取屏幕共享的媒体流</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> shareScreen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> localStream </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> navigator.mediaDevices.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getDisplayMedia</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    audio: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    video: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 播放本地视频流</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  playStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(localStream)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在视频标签中播放视频流</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> playStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">stream</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MediaStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> video</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#localVideo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HTMLVideoElement</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  video.srcObject </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stream</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>执行 <code>shareScreen</code> 函数后，会弹出一个权限询问框，询问是否允许获取屏幕共享的媒体流。</p><p>然后你就可以分享你的整个屏幕，如果你又多个屏幕的话，你可以选择其中一个进行分享<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cdd2153dabd4e88a802ea34d026cc70~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><p>然后你也可以选择只分享你屏幕上的某个应用的窗口，不用担心你一边干嘛干嘛一边录制屏幕，它只会捕捉你选择的应用窗口的内容。非常 nice。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbe6fa6e96b94a888266cf46ac39cee7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><p>你甚至可以在你浏览器打开的各种页面中，选择一个你想要分享的网页，当你页面各种切换时候，你的屏幕共享也只会显示你选择的网页的内容。</p><p>共享前你可以随便选一个进行预览，然后可以选择是否分享的时候包含页面中的音频，这样你获取的媒体流就会包含音频轨道了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d94b6755607462a9e5b88ed6c818fdc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><p>这里我打开自己 github 的网页，然后点击屏幕共享，可以看到共享的只有自己的 github 页面了。不用担心会有什么奇怪的东西乱入进来，非常适合视频会议或者在线教育等场景。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67221d90ba214be899bbf382e9410e76~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><p>说完获取屏幕媒体流，接下来我们来看看如何通过媒体流进行录制。</p><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.iana.org%2Fassignments%2Fmedia-types%2Fmedia-types.xhtml" title="https://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank" rel="noreferrer">完整的 MIME 类型列表</a></p><p>这里我们使用 <code>MediaRecorder</code> 来进行录制，它是一个用于录制媒体流的 API，它可以将媒体流中的数据进行录制，然后将录制的数据保存成一个文件。</p><p>由于 <code>MediaRecorder</code> api 的对 mimeType 参数的支持是有限的。所以我们需要通过 <code>MediaRecorder.isTypeSupported</code> 来判断当前浏览器是否支持我们需要的 mimeType。</p><p>chrome 中 <code>MediaRecorder</code> 支持的 <code>mimeType</code> 如下：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;video/webm&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;video/webm;codecs=vp8&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;video/webm;codecs=vp9&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;video/webm;codecs=h264&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;video/x-matroska;codecs=avc1&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5aeee0c5c5d4b2da70b56b51f900c14~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><p>为了验证上述的内容，这里我把一些常用的 mimeType 列出来，拼装后通过 <code>MediaRecorder.isTypeSupported</code> 来判断是否支持，最后放到下拉框中供用户根据自己的需求选择合适的 mimeType。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 获取支持的媒体类型</span></span>
<span class="line"><span>function getSupportedMimeTypes() {</span></span>
<span class="line"><span>  const media = &#39;video&#39;</span></span>
<span class="line"><span>  // 常用的视频格式</span></span>
<span class="line"><span>  const types = [</span></span>
<span class="line"><span>    &#39;webm&#39;,</span></span>
<span class="line"><span>    &#39;mp4&#39;,</span></span>
<span class="line"><span>    &#39;ogg&#39;,</span></span>
<span class="line"><span>    &#39;mov&#39;,</span></span>
<span class="line"><span>    &#39;avi&#39;,</span></span>
<span class="line"><span>    &#39;wmv&#39;,</span></span>
<span class="line"><span>    &#39;flv&#39;,</span></span>
<span class="line"><span>    &#39;mkv&#39;,</span></span>
<span class="line"><span>    &#39;ts&#39;,</span></span>
<span class="line"><span>    &#39;x-matroska&#39;,</span></span>
<span class="line"><span>  ]</span></span>
<span class="line"><span>  // 常用的视频编码</span></span>
<span class="line"><span>  const codecs = [&#39;vp9&#39;, &#39;vp9.0&#39;, &#39;vp8&#39;, &#39;vp8.0&#39;, &#39;avc1&#39;, &#39;av1&#39;, &#39;h265&#39;, &#39;h264&#39;]</span></span>
<span class="line"><span>  // 支持的媒体类型</span></span>
<span class="line"><span>  const supported: string[] = []</span></span>
<span class="line"><span>  const isSupported = MediaRecorder.isTypeSupported</span></span>
<span class="line"><span>  // 遍历判断所有的媒体类型</span></span>
<span class="line"><span>  types.forEach((type: string) =&gt; {</span></span>
<span class="line"><span>    const mimeType = \`\${media}/\${type}\`</span></span>
<span class="line"><span>    codecs.forEach((codec: string) =&gt;</span></span>
<span class="line"><span>      [</span></span>
<span class="line"><span>        \`\${mimeType};codecs=\${codec}\`,</span></span>
<span class="line"><span>        \`\${mimeType};codecs=\${codec.toUpperCase()}\`,</span></span>
<span class="line"><span>      ].forEach((variation) =&gt; {</span></span>
<span class="line"><span>        if (isSupported(variation)) supported.push(variation)</span></span>
<span class="line"><span>      }),</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span>    if (isSupported(mimeType)) supported.push(mimeType)</span></span>
<span class="line"><span>  })</span></span>
<span class="line"><span>  return supported</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(getSupportedMimeTypes())</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><p>可以看到这么多排列组合后，筛选出的支持的 mimeType 也就只有<code>&quot;video/webm&quot;</code>和 <code>&quot;video/x-matroska&quot;</code> 两种。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99a2702007dc4901bfa7c7539ffb8253~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><p>也可以通过这个网址<a href="https://link.juejin.cn/?target=https%3A%2F%2Fcconcolato.github.io%2Fmedia-mime-support%2F" title="https://cconcolato.github.io/media-mime-support/" target="_blank" rel="noreferrer">👉🏻media-mime-support</a> 来查看当前浏览器所支持的 mimeType 的情况。</p><p>目前最常用的一般都是 <code>video/mp4</code>。 截止到目前为止，最佳的 8 种视频格式为：<code>mp4</code> ,<code>webm</code> ,<code>mov</code> ,<code>avi</code> ,<code>mkv</code> ,<code>wmv</code> ,<code>avchd</code> ,<code>flv</code>。而 webm 是 Google 专门为 web 端推出的一种视频格式。100% 开源，且 100%兼容 Google Chrome 浏览器和 Android 设备。如果你没有强烈的需求，也可以使用 webm 格式。</p><p>说了这么多，不支持就不能录制成 mp4 了？🥲<br> 肯定不是啊 😂</p><p>都拿到 blob 了，可以通过 <code>ffmpeg.js</code> 来将 webm 格式转换成 mp4 格式，但是 <code>ffmpeg.js</code> 的体积比较大，太重了。这里也可以通过一种 hack 的方式来实现，但是不靠谱，这种方式导出的 mp4 文件部分软件可能会识别不了，求稳的话最好还是推荐使用我们浏览器环境列出的支持的 mimeType，或者用工具转一下)</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 录制媒体流</span></span>
<span class="line"><span>function startRecord() {</span></span>
<span class="line"><span>  const kbps = 1024</span></span>
<span class="line"><span>  const Mbps = kbps * kbps</span></span>
<span class="line"><span>  const options = {</span></span>
<span class="line"><span>    audioBitsPerSecond: 128000,</span></span>
<span class="line"><span>    videoBitsPerSecond: 2500000,</span></span>
<span class="line"><span>    mimeType: &#39;video/webm; codecs=&quot;vp8,opus&quot;&#39;,</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  const mediaRecorder = new MediaRecorder(localStream, options)</span></span>
<span class="line"><span>  mediaRecorder.start()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  mediaRecorder.ondataavailable = (e) =&gt; {</span></span>
<span class="line"><span>    // 将录制的数据合并成一个 Blob 对象</span></span>
<span class="line"><span>    // const blob = new Blob([e.data], { type: e.data.type })</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 🌸重点是这个地方，我们不要把获取到的 e.data.type设置成 blob 的 type，而是直接改成 mp4</span></span>
<span class="line"><span>    const blob = new Blob([e.data], { type: &#39;video/mp4&#39; })</span></span>
<span class="line"><span>    downloadBlob(blob)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  mediaRecorder.onstop = (e: Event) =&gt; {</span></span>
<span class="line"><span>    // 停止录制</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 下载 Blob</span></span>
<span class="line"><span>function downloadBlob(blob: Blob) {</span></span>
<span class="line"><span>  // 将 Blob 对象转换成一个 URL 地址</span></span>
<span class="line"><span>  const url = URL.createObjectURL(blob)</span></span>
<span class="line"><span>  const a = document.createElement(&#39;a&#39;)</span></span>
<span class="line"><span>  // 设置 a 标签的 href 属性为刚刚生成的 URL 地址</span></span>
<span class="line"><span>  a.href = url</span></span>
<span class="line"><span>  // 设置 a 标签的 download 属性为文件名</span></span>
<span class="line"><span>  a.download = \`\${new Date().getTime()}.\${blob.type.split(&#39;/&#39;)[1]}\`</span></span>
<span class="line"><span>  // 模拟点击 a 标签</span></span>
<span class="line"><span>  a.click()</span></span>
<span class="line"><span>  // 释放 URL 地址</span></span>
<span class="line"><span>  URL.revokeObjectURL(url)</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><p>然后我们就可以愉快的录制视频了。当然这里只是用分享屏幕的方式来录制视频，如果你想要录制摄像头的视频，也是一样，拿到媒体流后，就可以直接录制了。</p><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Ffrontend-park.vercel.app%2Faudio-and-video%2FwebRTC%2Faudio-and-video%2FwebRTC%2Frecord" title="https://frontend-park.vercel.app/audio-and-video/webRTC/audio-and-video/webRTC/record" target="_blank" rel="noreferrer">👉 线上体验地址：</a></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12fae373d86b4e9095d5c815a96eda46~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><p>当然，既然都拿到了媒体流，那么我们也可以将媒体流中的视频轨道录制成 gif 图片，这样在一些场景下分享起来也会更加方便。</p><p>由于 <code>MediaRecorder</code> api 不支持将 mimeType 设置成 image/gif ，所以我们需要借助一个第三方库<code>MediaStreamRecorder</code>来实现。它的用法和 <code>MediaRecorder</code> 基本一致。我就不再赘述了。</p><p>最后有一个需要注意的地方，也是我在实际项目中遇到的问题。截止到目前为止，在使用 <code>MediaRecorder</code> 录制视频的时候，如果你的系统是 Windows 或者 Chrome OS，那么录制的视频没什么问题，但是在 Mac 和 Linux 上，录制摄像头和分享屏幕时，选择网页的分享方式，所拿获得的媒体流是可以拿到视频轨道和音频轨道的，但是录制整个屏幕时，由于系统的限制，只能拿到视频的轨道。好在一般录屏都不会有带音频的需求，期待后面能够支持。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/245eb5e34b184764bde713c699a0e41c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><h2 id="实现视频的虚拟背景" tabindex="-1">实现视频的虚拟背景 <a class="header-anchor" href="#实现视频的虚拟背景" aria-label="Permalink to &quot;实现视频的虚拟背景&quot;">​</a></h2><p>在视频会议中，我们经常会看到一些人在视频中的背景是虚拟的，这样可以让我们更专注于对方的表情和语言，而不会被背景中的一些干扰因素所分散注意力。那么我们如何实现这样的效果呢？</p><p>下面我们先通过一个简单的 demo 来看看效果。</p><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Ffrontend-park.vercel.app%2Faudio-and-video%2FwebRTC%2Fbackground-process" title="https://frontend-park.vercel.app/audio-and-video/webRTC/background-process" target="_blank" rel="noreferrer">👉 线上体验地址</a></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb0c083b16fa42e2822fdfaefc1727d4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><p>主要原理是通过 <code>canvas</code> 将视频中的每一帧画到画布上，然后将画布中的像素逐个与设定的背景色（默认是绿色，你可以更换为任意符合你背景的颜色）进行计算，比较后的差值达到设定的阈值时，对其进行处理，将其更换为预先准备好的背景图的图像数据，最后将处理后的图像数据再画到虚拟背景画布上，通过虚拟背景画布拿到媒体流后给到 video 标签播放， 这样就实现了视频的虚拟背景效果。</p><p>下面我们来看看具体的实现。</p><p>为保持大小一致，这里我们统一设置画布和视频的宽高为 480*300。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>&lt;canvas id=&quot;backgroundImg&quot; width=&quot;480&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt;</span></span>
<span class="line"><span>&lt;video id=&quot;real-video&quot; width=&quot;480&quot; height=&quot;300&quot; autoplay muted&gt;&lt;/video&gt;</span></span>
<span class="line"><span>&lt;video id=&quot;virtual-video&quot; width=&quot;480&quot; height=&quot;300&quot; autoplay muted&gt;&lt;/video&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>首先我们需要准备好背景图，这里我使用了一张图片，你也可以使用视频作为背景。</p><p>通过 canvas 将背景图画到画布上，然后通过 <code>getImageData</code> 方法拿到图像数据。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 虚拟背景的 canvas中的图片数据</span></span>
<span class="line"><span>let backgroundImageData: ImageData</span></span>
<span class="line"><span>// 获取背景图像数据</span></span>
<span class="line"><span>function getBackgroundImageData() {</span></span>
<span class="line"><span>  const backgroundCanvas = document.querySelector(</span></span>
<span class="line"><span>    &#39;#backgroundImg&#39;,</span></span>
<span class="line"><span>  ) as HTMLCanvasElement</span></span>
<span class="line"><span>  const backgroundCtx = backgroundCanvas.getContext(&#39;2d&#39;)!</span></span>
<span class="line"><span>  const img = new Image()</span></span>
<span class="line"><span>  img.src = &#39;https://xxxx.png&#39;</span></span>
<span class="line"><span>  img.onload = () =&gt; {</span></span>
<span class="line"><span>    backgroundCtx.drawImage(</span></span>
<span class="line"><span>      img,</span></span>
<span class="line"><span>      0,</span></span>
<span class="line"><span>      0,</span></span>
<span class="line"><span>      backgroundCanvas.width,</span></span>
<span class="line"><span>      backgroundCanvas.height,</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    backgroundImageData = backgroundCtx.getImageData(</span></span>
<span class="line"><span>      0,</span></span>
<span class="line"><span>      0,</span></span>
<span class="line"><span>      backgroundCanvas.width,</span></span>
<span class="line"><span>      backgroundCanvas.height,</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>然后我们需要通过摄像头获取到视频流，还是用之前几个 demo 中的方法。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 获取本地音视频流</span></span>
<span class="line"><span>async function getLocalStream(options: MediaStreamConstraints) {</span></span>
<span class="line"><span>  const stream = await navigator.mediaDevices.getUserMedia(options)</span></span>
<span class="line"><span>  return stream</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 播放原始视频流</span></span>
<span class="line"><span>function playRealVideo(stream: MediaStream) {</span></span>
<span class="line"><span>  realVideo = document.querySelector(&#39;#real-video&#39;) as HTMLVideoElement</span></span>
<span class="line"><span>  realVideo.srcObject = stream</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>上述步骤完成后，我们就可以通过创建 <code>canvas</code> 标签 先将真实的视频每隔 40ms 一次 画到画布上。</p><p>这样的话，画布就会不断的更新，能达到 25 帧的效果，这样能保证我们的视频流是非常流畅的。</p><p>一般来说，人眼舒适放松时可视帧数是每秒 24 帧，高度集中精神时不超过 30 帧。电影院里的 2D 电影一般是 24 帧的，3D 电影一般是 60 帧以上。</p><p>画到画布后，我们也相应的要通过 <code>getImageData</code> 方法拿到真实视频的图像数据。</p><p>然后每一帧都要与设置好的背景色进行比较，比较后的差值达到设定的阈值的像素，就要扣除（替换为之前拿到的背景图的像素。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1d64a29c3c24d828f117d9951d6aba1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0ab76d1315c42fca106ade3f82a3b6b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><p>看到这里,如果以前看过我的文章，大家一定很眼熟，这个计算颜色差的逻辑与我之前写的<a href="https://juejin.cn/post/6996431901623844894" title="https://juejin.cn/post/6996431901623844894" target="_blank" rel="noreferrer">《我用 10000 张图片合成我们美好的瞬间》</a>用来做合成图的逻辑是一样的。</p><p>首先需要明白的一点就是，rgb 的色域是一个 3 维的空间，我们可以通过计算两个点之间的距离来判断两个颜色的差异。距离越小，颜色差异越小。</p><p>而这只需要我们中学时期学过的 欧式距离 公式就可以了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23ed293fcf8f44898e00d32e5373c4ae~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><p>我们把它转化为颜色差的计算公式如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 计算颜色差</span></span>
<span class="line"><span>function colorDiff(color1: number[], color2: number[]) {</span></span>
<span class="line"><span>  const r = color1[0] - color2[0]</span></span>
<span class="line"><span>  const g = color1[1] - color2[1]</span></span>
<span class="line"><span>  const b = color1[2] - color2[2]</span></span>
<span class="line"><span>  return Math.sqrt(r * r + g * g + b * b)</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>然后再将处理后的图像数据画到虚拟视频的画布上，再通过<code>captureStream</code>api 将画布转换为视频流，最后将视频流赋值给虚拟视频的 <code>srcObject</code> 属性。</p><p>代码如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const WIDTH = 480 // 视频宽度</span></span>
<span class="line"><span>const HEIGHT = 300 // 视频高度</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 将视频写到 canvas 中</span></span>
<span class="line"><span>function drawVideoToCanvas(realVideo: HTMLVideoElement) {</span></span>
<span class="line"><span>  realVideoCanvas = document.createElement(&#39;canvas&#39;) as HTMLCanvasElement</span></span>
<span class="line"><span>  realVideoCtx = realVideoCanvas.getContext(&#39;2d&#39;)!</span></span>
<span class="line"><span>  virtualVideoCanvas = document.createElement(&#39;canvas&#39;) as HTMLCanvasElement</span></span>
<span class="line"><span>  virtualVideoCtx = virtualVideoCanvas.getContext(&#39;2d&#39;)!</span></span>
<span class="line"><span>  realVideoCanvas.width = virtualVideoCanvas.width = WIDTH</span></span>
<span class="line"><span>  realVideoCanvas.height = virtualVideoCanvas.height = HEIGHT</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 每隔 100ms 将真实的视频写到 canvas 中，并获取视频的图像数据</span></span>
<span class="line"><span>  setInterval(() =&gt; {</span></span>
<span class="line"><span>    realVideoCtx.drawImage(</span></span>
<span class="line"><span>      realVideo,</span></span>
<span class="line"><span>      0,</span></span>
<span class="line"><span>      0,</span></span>
<span class="line"><span>      realVideoCanvas.width,</span></span>
<span class="line"><span>      realVideoCanvas.height,</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span>    // 获取 realVideoCanvas 中的图像数据</span></span>
<span class="line"><span>    realVideoImageData = realVideoCtx.getImageData(</span></span>
<span class="line"><span>      0,</span></span>
<span class="line"><span>      0,</span></span>
<span class="line"><span>      realVideoCanvas.width,</span></span>
<span class="line"><span>      realVideoCanvas.height,</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span>    // 处理真实视频的图像数据，将其写到虚拟视频的 canvas 中</span></span>
<span class="line"><span>    processFrameDrawToVirtualVideo()</span></span>
<span class="line"><span>  }, 40)</span></span>
<span class="line"><span>  // 从 VirtualVideoCanvas 中获取视频流并在 virtualVideo 中播放</span></span>
<span class="line"><span>  getStreamFromVirtualVideoCanvas()</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 从 VirtualVideoCanvas 中获取视频流并在 virtualVideo 中播放</span></span>
<span class="line"><span>function getStreamFromVirtualVideoCanvas() {</span></span>
<span class="line"><span>  virtualVideo = document.querySelector(&#39;#virtual-video&#39;) as HTMLVideoElement</span></span>
<span class="line"><span>  const stream = virtualVideoCanvas.captureStream(30)</span></span>
<span class="line"><span>  virtualVideo.srcObject = stream</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><p>逐像素计算与要处理的目标颜色的差值，如果差值小于容差，则将该像素设置为背景图片中的对应像素</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 处理真实视频的图像数据，将其写到虚拟视频的 canvas 中</span></span>
<span class="line"><span>function processFrameDrawToVirtualVideo() {</span></span>
<span class="line"><span>  // 逐像素计算与要处理的目标颜色的差值，如果差值小于阈值，则将该像素设置为背景图片中的对应像素</span></span>
<span class="line"><span>  for (let i = 0; i &lt; realVideoImageData.data.length; i += 4) {</span></span>
<span class="line"><span>    const r = realVideoImageData.data[i]</span></span>
<span class="line"><span>    const g = realVideoImageData.data[i + 1]</span></span>
<span class="line"><span>    const b = realVideoImageData.data[i + 2]</span></span>
<span class="line"><span>    const a = realVideoImageData.data[i + 3]</span></span>
<span class="line"><span>    const bgR = backgroundImageData.data[i]</span></span>
<span class="line"><span>    const bgG = backgroundImageData.data[i + 1]</span></span>
<span class="line"><span>    const bgB = backgroundImageData.data[i + 2]</span></span>
<span class="line"><span>    const bgA = backgroundImageData.data[i + 3]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 计算与背景色的差值</span></span>
<span class="line"><span>    const diff = colorDiff([r, g, b], backgroundColor)</span></span>
<span class="line"><span>    // 当差值小于设定的阈值，则将该像素设置为背景图片中的对应像素</span></span>
<span class="line"><span>    if (diff &lt; allowance.value) {</span></span>
<span class="line"><span>      realVideoImageData.data[i] = bgR</span></span>
<span class="line"><span>      realVideoImageData.data[i + 1] = bgG</span></span>
<span class="line"><span>      realVideoImageData.data[i + 2] = bgB</span></span>
<span class="line"><span>      realVideoImageData.data[i + 3] = bgA</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  // 将处理后的图像数据写到虚拟视频的 canvas 中</span></span>
<span class="line"><span>  virtualVideoCtx.putImageData(realVideoImageData, 0, 0)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 计算颜色差异</span></span>
<span class="line"><span>function colorDiff(rgba1: number[], rgba2: number[]) {</span></span>
<span class="line"><span>  let d = 0</span></span>
<span class="line"><span>  for (let i = 0; i &lt; rgba1.length; i++) {</span></span>
<span class="line"><span>    d += (rgba1[i] - rgba2[i]) ** 2</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return Math.sqrt(d)</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>可以看到，其中<code>backgroundColor</code>（需要扣除的背景色）和<code>allowance</code>（容差值）两个变量是由外部控制的，这样我们就可以在页面上通过滑动条或是其他的组件来动态改变容差，通过取色器来动态改变需要扣除的背景色。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4c4a4c37dd140d689892b22cd3dba78~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><h2 id="最后" tabindex="-1">最后 <a class="header-anchor" href="#最后" aria-label="Permalink to &quot;最后&quot;">​</a></h2><p>至此，我们就可以实现一个简单的背景替换的功能了。当然，这里只是简单的实现了一个背景替换的功能，实际上，我们还可以通过更多的技术手段来实现更加复杂的功能，比如：</p><p>目前只是针对纯色的背景进行了替换，如果复杂的背景，我们可以通过图像分割的方式来实现背景替换，比如：TensorFlow.js 中的 身体分割（BodyPix）。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f262d5322e6641f7a35ae91bd60355ef~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p><p>或者是说，对于视频中的人脸，我们可以通过<code>face-api.js</code>来检测人脸，并将人脸替换为其他的图片，从而实现一个简单的换脸功能。对于视频中的人体，我们可以通过<code>BodyPix</code>来检测人体，并将人体替换为其他的图片，从而实现一个简单的换装功能。等等...（后续我都在这个专栏中安排~）</p><p>可以见得，用 WebRTC 相关的知识来结合一些其他相关技术，可以实现非常多的有趣的项目，可玩性非常强。</p><p>这作为我专栏的第一篇，主要是想通过这篇文章来介绍一下 WebRTC 相关的知识，以及 WebRTC 相关的一些应用场景，希望能够帮助到大家。</p><p>本来还想写下 1v1 视频聊天的实现，但是由于时间关系，我把它放到第二篇来写吧，demo 我已经放到了 我的<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwangrongding%2Ffrontend-park" title="https://github.com/wangrongding/frontend-park" target="_blank" rel="noreferrer">前端公园合集仓库</a>中，这两天抽空写完,大家也可以 follow 一下我的 Github，谢谢大家~ 🌸</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af50e747a22849e5a44ad1543f471f03~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图片"></p>`,131);function o(m,g,u,E,y,v){const i=n("ArticleMetadata"),p=n("ClientOnly");return l(),t("div",null,[d,s(p,null,{default:r(()=>[s(i)]),_:1}),b])}const f=e(k,[["render",o]]);export{C as __pageData,f as default};
