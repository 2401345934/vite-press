import{_ as c,o as p,c as r,J as e,w as i,m as a,a as l,aa as s,E as n}from"./chunks/framework.DJCjJe2w.js";const j=JSON.parse('{"title":"npm 安装流程","description":"","frontmatter":{"createTime":"2022/11/02","tag":"工程化,npm"},"headers":[],"relativePath":"engineering/npm/npm-install/index.md","filePath":"engineering/npm/npm-install/index.md","lastUpdated":1667570087000}'),m={name:"engineering/npm/npm-install/index.md"},d=a("h1",{id:"npm-安装流程",tabindex:"-1"},[l("npm 安装流程 "),a("a",{class:"header-anchor",href:"#npm-安装流程","aria-label":'Permalink to "npm 安装流程"'},"​")],-1),_=s('<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c87b3d0879fc411fbbde141261c0720d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="图片"></p><h2 id="第一步" tabindex="-1">第一步 <a class="header-anchor" href="#第一步" aria-label="Permalink to &quot;第一步&quot;">​</a></h2><p>执行安装命令之后，npm 首先会去查找 npm 的配置信息。 其中，我们最熟悉的就是安装时候的源信息。npm 会在项目中查找是否有 .npmrc 文件，没有的话会再检查全局配置的 .npmrc ，还没有的话就会使用 npm 内置的 .npmrc 文件。</p><h2 id="第二步" tabindex="-1">第二步 <a class="header-anchor" href="#第二步" aria-label="Permalink to &quot;第二步&quot;">​</a></h2><p>获取完配置文件之后，就会构建依赖树。 首先会检查下项目中是否有 package-lock.json 🔐文件：存在 lock 文件的话，会判断 lock 文件和 package.json 中使用的依赖版本是否一致，如果一致的话就使用 lock 中的信息，反之就会使用 npm 中的信息；那如果没有 lock 文件的话，就会直接使用 package.json 中的信息生成依赖树。（具体是怎么生成依赖树的呢？下面会详细介绍。）</p><h2 id="第三步" tabindex="-1">第三步 <a class="header-anchor" href="#第三步" aria-label="Permalink to &quot;第三步&quot;">​</a></h2><p>在有了依赖树之后，就可以根据依赖树下载完整的依赖资源。 在下载之前，会先检查下是否有缓存资源，如果存在缓存资源的话，那么直接将缓存资源解压到 node_modules 中。如果没有缓存资源，那么会先将 npm 远程仓库中的包下载至本地，然后会进行包的完整性校验，校验通过后将其添加的缓存中并解压到 node_modules 中。</p><p>npm 默认不会将依赖安装到全局，只会安装到当前的路径下，这样设计是为了不同的项目之间进行依赖隔离，互不影响。当然，用户也可以选择安装到全局，只需要在安装命令后带上 -g 参数即可。</p><h2 id="第四步" tabindex="-1">第四步 <a class="header-anchor" href="#第四步" aria-label="Permalink to &quot;第四步&quot;">​</a></h2><p>会生成 package-lock.json 文件。 那么这个文件是干什么的呢？我们都知道，在 package.json 文件中，如果我们在依赖的版本号前增加 ^ 标志的话，比如 ^3.1.6 意味着安装的时候会安装 3.x.x 的大版本中最新的小版本。这样，不同的时间执行安装操作就会有不同的结果。所以 lock 这个文件会将本次安装的依赖的版本信息记录下来，在下次再安装的时候，或者其他伙伴使用该包，或者通过 CI 工具的时候，就会安装相同版本的依赖。这样就会避免 package.json 中的内容一致但是实际上安装依赖的版本不一致而造成 Bug 出现的情况</p>',10);function h(k,u,f,g,b,x){const t=n("ArticleMetadata"),o=n("ClientOnly");return p(),r("div",null,[d,e(o,null,{default:i(()=>[e(t)]),_:1}),_])}const q=c(m,[["render",h]]);export{j as __pageData,q as default};
