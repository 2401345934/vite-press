import{_ as n,o as p,c as l,J as s,w as r,m as a,a as h,aa as o,E as i}from"./chunks/framework.DJCjJe2w.js";const y=JSON.parse('{"title":"给 npm script 传递参数和添加注释","description":"","frontmatter":{"createTime":"2022/11/02","tag":"工程化,npm"},"headers":[],"relativePath":"engineering/npm/parameter-script/index.md","filePath":"engineering/npm/parameter-script/index.md","lastUpdated":1667401036000}'),c={name:"engineering/npm/parameter-script/index.md"},d=a("h1",{id:"给-npm-script-传递参数和添加注释",tabindex:"-1"},[h("给 npm script 传递参数和添加注释 "),a("a",{class:"header-anchor",href:"#给-npm-script-传递参数和添加注释","aria-label":'Permalink to "给 npm script 传递参数和添加注释"'},"​")],-1),m=o(`<h2 id="给-npm-script-传递参数" tabindex="-1">给 npm script 传递参数 -- <a class="header-anchor" href="#给-npm-script-传递参数" aria-label="Permalink to &quot;给 npm script 传递参数 --&quot;">​</a></h2><p>eslint 内置了代码风格自动修复模式，只需给它传入 --fix 参数即可，在 scripts 中声明检查代码命令的同时你可能也需要声明修复代码的命令，面对这种需求，大多数同学可能会忍不住复制粘贴，如下：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;lint:js:fix&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;eslint *.js --fix&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在 lint:js 命令比较短的时候复制粘贴的方法简单粗暴有效，但是当 lint:js 命令变的很长之后，难免后续会有人改了 lint:js 而忘记修改 lint:js:fix（别问我为啥，我就是踩着坑过来的），更健壮的做法是，在运行 npm script 时给定额外的参数，代码修改如下</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;lint:js:fix&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;npm run lint:js -- --fix&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>要格外注意 --fix 参数前面的 -- 分隔符，意指要给 npm run lint:js 实际指向的命令传递额外的参数。</p><h2 id="给-npm-script-添加注释" tabindex="-1">给 npm script 添加注释 <a class="header-anchor" href="#给-npm-script-添加注释" aria-label="Permalink to &quot;给 npm script 添加注释&quot;">​</a></h2><h3 id="第一种" tabindex="-1">第一种 <a class="header-anchor" href="#第一种" aria-label="Permalink to &quot;第一种&quot;">​</a></h3><p>package.json 中可以增加 // 为键的值，注释就可以写在对应的值里面，npm 会忽略这种键，比如，我们想要给 test 命令添加注释，按如下方式添加</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;//&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;运行所有代码检查和单元测试&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     &quot;test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;npm-run-all --parallel lint:* mocha&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这种方式的明显不足是，npm run 列出来的命令列表不能把注释和实际命令对应上，如果你声明了多个，npm run 只会列出最后那个，如下图：</p><h3 id="第二种" tabindex="-1">第二种 <a class="header-anchor" href="#第二种" aria-label="Permalink to &quot;第二种&quot;">​</a></h3><p>直接在 script 声明中做手脚，因为命令的本质是 shell 命令（适用于 linux 平台），我们可以在命令前面加上注释，具体做法如下：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;# 运行所有代码检查和单元测试 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    npm-run-all --parallel lint:* mocha&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>注意注释后面的换行符 \\n 和多余的空格，换行符是用于将注释和命令分隔开，这样命令就相当于微型的 shell 脚本，多余的空格是为了控制缩进，也可以用制表符 \\t 替代。这种做法能让 npm run 列出来的命令更美观，但是 scripts 声明阅读起来不那么整齐美观。 <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/27/15ffa72c247900f5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图片"></p><h2 id="调整-npm-script-运行时日志输出" tabindex="-1">调整 npm script 运行时日志输出 <a class="header-anchor" href="#调整-npm-script-运行时日志输出" aria-label="Permalink to &quot;调整 npm script 运行时日志输出&quot;">​</a></h2><p>在运行 npm script 出现问题时你需要有能力去调试它，某些情况下你需要让 npm script 以静默的方式运行，这类需求可通过控制运行时日志输出级别来实现。</p><p>日志级别控制参数有好几个，简单举例如下：</p><h3 id="默认日志输出级别" tabindex="-1">默认日志输出级别 <a class="header-anchor" href="#默认日志输出级别" aria-label="Permalink to &quot;默认日志输出级别&quot;">​</a></h3><p>即不加任何日志控制参数得到的输出，可能是你最常用的，能看到执行的命令、命令执行的结果。</p><h3 id="显示尽可能少的有用信息" tabindex="-1">显示尽可能少的有用信息 <a class="header-anchor" href="#显示尽可能少的有用信息" aria-label="Permalink to &quot;显示尽可能少的有用信息&quot;">​</a></h3><p>结合其他工具调用 npm script 的时候比较有用，需要使用 --loglevel silent，或者 --silent，或者更简单的 -s 来控制，这个日志级别的输出实例如下（只有命令本身的输出，读起来非常的简洁）：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/27/15ffa73279c8a9e8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图片"> 如果执行各种 lint script 的时候启用了 -s 配置，代码都符合规范的话，你不会看到任何输出，这就是没有消息是最好的消息的由来，哈哈！</p><h3 id="显示尽可能多的运行时状态" tabindex="-1">显示尽可能多的运行时状态 <a class="header-anchor" href="#显示尽可能多的运行时状态" aria-label="Permalink to &quot;显示尽可能多的运行时状态&quot;">​</a></h3><p>排查脚本问题的时候比较有用，需要使用 --loglevel verbose，或者 --verbose，或者更简单的 -d 来控制，这个日志级别的输出实例如下（详细打印出了每个步骤的参数、返回值，下面的截图只是部分）：</p>`,25);function u(k,g,b,E,v,q){const e=i("ArticleMetadata"),t=i("ClientOnly");return p(),l("div",null,[d,s(t,null,{default:r(()=>[s(e)]),_:1}),m])}const _=n(c,[["render",u]]);export{y as __pageData,_ as default};
